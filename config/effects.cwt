### Sets whether a building is subsidized set_subsidized = yes/no
alias[effect:set_subsidized] = bool

### Adds the specified number of percentage points to a civil war progress (range is [0, 1], 0.1 means 10 percentage points) add_civil_war_progress = 0.1 / -0.1
alias[effect:add_civil_war_progress] = value_field[-1..1]

### Adds war exhaustion to the target country in the scoped war. The amount will appear under the 'situations' header in tooltips add_war_exhaustion = { target = country value = value }
alias[effect:add_war_exhaustion] = {
    target = scope[country]
    value = value_field
}

### Adds war support to the target country in the scoped war. The amount will appear under the 'situations' header in tooltips add_war_war_support = { target = country value = value }
alias[effect:add_war_war_support] = {
    target = scope[country]
    value = value_field
}

### Adds a new obsession to the culture in scope add_cultural_obsession = X Where X is a goods
alias[effect:add_cultural_obsession] = <goods>

### Removes a new obsession to the culture in scope remove_cultural_obsession = X Where X is a goods
alias[effect:remove_cultural_obsession] = <goods>

### Adds a new role to a character add_character_role = general
alias[effect:add_character_role] = enum[character_role]

### Promotes/demotes a character a given amount of military ranks
alias[effect:add_commander_rank] = int_value_field

### Adds an amount of experience to a commander add_experience = 0.2
alias[effect:add_experience] = value_field

### Adds a random qualifying Trait of the specified category add_random_trait = personality / skill / condition
alias[effect:add_random_trait] = enum[character_trait_type]

### Add a trait to a Character add_trait = trait
alias[effect:add_trait] = <character_trait>

### Changes the religion of the scoped character change_character_religion = rel:protestant
alias[effect:change_character_religion] = scope[religion]

### Frees a character from the void, if set to no character is deleted instead free_character_from_void = yes
alias[effect:free_character_from_void] = bool

### Kill a character kill_character = bool
alias[effect:kill_character] = bool

### Banishes a character to the void, duration is how long character is kept before being deleted place_character_in_void = months
alias[effect:place_character_in_void] = int_value_field

### Removes a character from position as interest group leader remove_as_interest_group_leader = yes
alias[effect:remove_as_interest_group_leader] = yes

### Remove a trait from a Character remove_trait = trait
alias[effect:remove_trait] = <character_trait>

### Sets a character as interest group leader set_as_interest_group_leader = yes
alias[effect:set_as_interest_group_leader] = yes

### Mark a character as busy or clear said mark set_character_busy = bool
alias[effect:set_character_busy] = bool

### Promotes/demotes a character to a given military rank value set_commander_rank = 3
alias[effect:set_commander_rank] = int_value_field

### Changes scoped character's ideology set_ideology = x
alias[effect:set_ideology] = <ideology>

### Transfers a Character to Country
alias[effect:transfer_character] = scope[country]

### Adds a timed modifier effect to object in scope
alias[effect:add_modifier] = {
    name = <modifier_container>
    ## cardinality = 0..1
    enum[duration] = int
    ## cardinality = 0..1
    multiplier = value_field
    ## cardinality = 0..1
    is_decaying = bool
}

### Removes a timed modifier effect to object in scope
alias[effect:remove_modifier] = <modifier_container>

### Removes interest group from revolution abandon_revolution = yes/no
alias[effect:abandon_revolution] = bool

### Adds an ideology to scoped interest group add_ideology = x
alias[effect:add_ideology] = <ideology>

### Adds interest group to government add_ruling_interest_group = yes/no
alias[effect:add_ruling_interest_group] = bool

### Adds interest group to ongoing revolution join_revolution = yes/no
alias[effect:join_revolution] = bool

### Removes an ideology from scoped interest group remove_ideology = x
alias[effect:remove_ideology] = <ideology>

### Removes interest group in scope from government remove_ruling_interest_group = yes/no
alias[effect:remove_ruling_interest_group] = bool

### Starts/stops bolstering the interest group in scope set_ig_bolstering = yes/no
alias[effect:set_ig_bolstering] = bool

### Starts/stops suppressing the interest group in scope set_ig_suppression = yes/no
alias[effect:set_ig_suppression] = bool

### Renames interest group to the specified loc key set_interest_group_name = x
alias[effect:set_interest_group_name] = localisation

### Lock a trade route for a set amount of time, preventing it from being cancelled manually lock_trade_route = { 	years = 5 }
alias[effect:lock_trade_route] = {
    enum[duration] = int
}

### Adds momentum to a Party during a campaign period dd_momentum = value
alias[effect:add_momentum] = value_field

### Adds a journal entry to a scoped country's journal, with optional saved scope target add_journal_entry = { type = <key> target = <scope> }
alias[effect:add_journal_entry] = {
    type = <journal_entry>
    ## cardinality = 0..1
    target = scope_field
}

### Adds the event target to a variable list add_to_variable_list = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:add_to_global_variable_list] = {
    name = value_set[global_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the (unbroken) event chain add_to_list = <string> NOTE, if adding a permanent target to a temporary list, the whole list becomes permanent
alias[effect:add_to_list] = value_set[list]

### Adds the event target to a variable list add_to_variable_list = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:add_to_local_variable_list] = {
    name = value_set[local_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the same effect add_to_temporary_list = <string> NOTE, if adding a temporary target to a permanent list, the list will stay permanent
alias[effect:add_to_temporary_list] = value_set[temporary_list]

### Adds the event target to a variable list add_to_variable_list = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:add_to_variable_list] = {
    name = value_set[variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Conditionally cause an assert during run time assert_if = { limit = { X } text = Y }, where X is a trigger and Y is an optional string
alias[effect:assert_if] = {
    limit = {
        ## cardinality = 1..inf
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    text = localisation
}

### Conditionally cause an assert during read time assert_read = X, where X is yes or the string to be printed in the assert
alias[effect:assert_read] = yes

### Conditionally cause an assert during read time assert_read = X, where X is yes or the string to be printed in the assert
alias[effect:assert_read] = scalar

### Changes the value or a numeric variable change_variable = { name = X operation = Y } Where X is the name of the numeric variable to modify Where the valid operations are add, subtract, multiply, divide and modulo Where Y is a fixed point value, script value or event target of a value type
alias[effect:change_global_variable] = {
    name = value[global_variable]
    alias_name[arithmetic_operation] = alias_match_left[arithmetic_operation]
}

### Change infamy of scope country change_infamy = amount
alias[effect:change_infamy] = value_field

### Changes the value or a numeric variable change_variable = { name = X operation = Y } Where X is the name of the numeric variable to modify Where the valid operations are add, subtract, multiply, divide and modulo Where Y is a fixed point value, script value or event target of a value type
alias[effect:change_local_variable] = {
    name = value[local_variable]
    alias_name[arithmetic_operation] = alias_match_left[arithmetic_operation]
}

### Changes the value or a numeric variable change_variable = { name = X operation = Y } Where X is the name of the numeric variable to modify Where the valid operations are add, subtract, multiply, divide and modulo Where Y is a fixed point value, script value or event target of a value type
alias[effect:change_variable] = {
    name = value[variable]
    alias_name[arithmetic_operation] = alias_match_left[arithmetic_operation]
}

### Clamps a variable the specified max and min clamp_variable = { name = X max = Y min = Z } Where X is the name of the variable Where Y and Z are script values
alias[effect:clamp_global_variable] = {
    name = value[global_variable]
    max = value_field
    min = value_field
}

### Clamps a variable the specified max and min clamp_variable = { name = X max = Y min = Z } Where X is the name of the variable Where Y and Z are script values
alias[effect:clamp_local_variable] = {
    name = value[local_variable]
    max = value_field
    min = value_field
}

### Clamps a variable the specified max and min clamp_variable = { name = X max = Y min = Z } Where X is the name of the variable Where Y and Z are script values
alias[effect:clamp_variable] = {
    name = value[variable]
    max = value_field
    min = value_field
}

### Empties the list clear_variable_list = variable_name
alias[effect:clear_global_variable_list] = value[global_variable_list]

### Empties the list clear_variable_list = variable_name
alias[effect:clear_local_variable_list] = value[local_variable_list]

### Clears a saved scope from the top scope save_scope_as = cool_scope -> clear_saved_scope = cool_scope
alias[effect:clear_saved_scope] = value[event_target]

### Empties the list clear_variable_list = variable_name
alias[effect:clear_variable_list] = value[variable_list]

### Creates a new country create_country = { 	tag = TAG			# optional, if not specified origin's tag will be used 	origin = country	# optional, newly created country will inherit certain values from the origin country 	                    # at least one of tag or origin must be supplied 	state = state		# can be repeated; at least one state or province must be supplied 	province = province	# can be repeated; at least one state or province must be supplied 						# both states and provinces can be supplied at the same time 	on_created = effect	# optional effect that will be run with the newly created country in scope }
alias[effect:create_country] = {
    ## cardinality = 0..1
    tag = <country_definition>
    ## cardinality = 0..1
    origin = scope[country]
    ## cardinality = 0..inf
    state = scope[state]
    ## cardinality = 0..inf
    province = scope[province]
    ## push_scope = country
    ## cardinality = 0..1
    on_created = single_alias_right[effect_clause]
}

### Wraps effects that get a custom description instead of the auto-generated one custom_description = { 	text = <effect_localization_key> 	subject = <optional subject scope> #defaults to current scope 	object = <optional object scope> 	value = <optional script value> 	... effects ... }
alias[effect:custom_description] = replace_me

### Wraps effects that get a custom description instead of the auto-generated one. Also ensures no bullet point appears custom_description_no_bullet = { 	text = <effect_localization_key> 	subject = <optional subject scope> #defaults to current scope 	object = <optional object scope> 	value = <optional script value> 	... effects ... }
alias[effect:custom_description_no_bullet] = replace_me

### just a tooltip, the scope as object (for grouping, localization). Can also be written as custom_label = { text = key subject = scope (optional) <hidden effects> }
alias[effect:custom_label] = localisation

### just a tooltip, the scope as subject (for grouping, localization). Can also be written as custom_tooltip = { text = key subject = scope (optional) <hidden effects> }
alias[effect:custom_tooltip] = localisation
### just a tooltip, the scope as subject (for grouping, localization). Can also be written as custom_tooltip = { text = key subject = scope (optional) <hidden effects> }
alias[effect:custom_tooltip] = {
    text = localisation
    ## cardinality = 0..1
    subject = scope_field
    alias_name[effect] = alias_match_left[effect]
}

### Log a string to the debug log when this effect executes, debug_log = message, the message can be a localization string with ROOT, SCOPE and PREV available
alias[effect:debug_log] = localisation

### Log the current scope to the debug log when this effect executes yes = full scope info, no=only current scope
alias[effect:debug_log_scopes] = bool

### Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met if = { limit = { <triggers> } <effects> } else = { <effects> }
alias[effect:else] = {
    ## cardinality = 1..inf
    alias_name[effect] = alias_match_left[effect]
}

### Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met, and its own limit is met if = { limit = { <triggers> } <effects> } else_if = { limit = { <triggers> } <effects> }
alias[effect:else_if] = {
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    alias_name[effect] = alias_match_left[effect]
}

### Effect not shown in tooltips
alias[effect:hidden_effect] = {
    ## cardinality = 1..inf
    alias_name[effect] = alias_match_left[effect]
}

### Executes enclosed effects if limit criteria are met if = { limit = { <triggers> } <effects> }
alias[effect:if] = {
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    alias_name[effect] = alias_match_left[effect]
}

### Posts notification
alias[effect:post_notification] = <notification_type>

### Posts proposal
alias[effect:post_proposal] = <proposal_type>

### a random effect, random = { chance = X modifier = Y effects... } where X is a chance of the enclosed effects being fired and can be modified by optional value modifier list (AKA MTTH) Y
alias[effect:random] = {
    chance = int_value_field

    ## cardinality = 0..inf
    modifier = single_alias_right[weight_chance_modifier]

    ## cardinality = 1..inf
    alias_name[effect] = alias_match_left[effect]
}

### Removes the current scope from a named list remove_from_list = <string>
alias[effect:remove_from_list] = value[list]

### Removes a variable remove_variable = variable_name
alias[effect:remove_global_variable] = value[global_variable]

### Removes the target from a variable list remove_list_variable = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:remove_list_global_variable] = {
    name = value[global_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Removes the target from a variable list remove_list_variable = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:remove_list_local_variable] = {
    name = value[local_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Removes the target from a variable list remove_list_variable = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:remove_list_variable] = {
    name = value[variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Removes a variable remove_variable = variable_name
alias[effect:remove_local_variable] = value[local_variable]

### Removes a variable remove_variable = variable_name
alias[effect:remove_variable] = value[variable]

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:remove_global_variable] = value[global_variable]

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:remove_local_variable] = value[local_variable]

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:round_variable] = {
    name = value[variable]
    nearest = value_field
}

### Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain save_event_target_as = <string>
alias[effect:save_scope_as] = value_set[event_target]

### Saves a numerical or bool value as an arbitrarily-named target to be referenced later in the (unbroken) event chain save_scope_value_as = { name = <string> value = x }
alias[effect:save_scope_value_as] = {
    name = value_set[event_target]
    value = value_field
}

### Saves the current scope as an arbitrarily-named temporary target to be referenced later in the same effect save_temporary_event_target_as = <string>
alias[effect:save_temporary_scope_value_as] = {
    name = value_set[temporary_scope]
    value = value_field
}

### Saves a numerical or bool value as an arbitrarily-named temporary target to be referenced later in the same effect save_temporary_scope_value_as = { name = <string> value = x }
alias[effect:save_temporary_scope_value_as] = {
    name = value_set[temporary_scope]
    value = value_field
}

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope Can also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })
alias[effect:set_global_variable] = {
    name = value_set[global_variable]

    ## cardinality = 0..1
    enum[duration] = int

    ## cardinality = 0..1
    value = value_field
    ## cardinality = 0..1
    value = scope_field
}

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_global_variable] = value_set[global_variable]

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_local_variable] = {
    name = value_set[local_variable]

    ## cardinality = 0..1
    enum[duration] = int

    ## cardinality = 0..1
    value = value_field
    ## cardinality = 0..1
    value = scope_field
}

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_local_variable] = value_set[local_variable]

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_variable] = {
    name = value_set[variable]

    ## cardinality = 0..1
    enum[duration] = int

    ## cardinality = 0..1
    value = value_field
    ## cardinality = 0..1
    value = scope_field
}

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_variable] = value_set[variable]

### Effect only shown in tooltips (but not executed)
alias[effect:show_as_tooltip] = single_alias_right[effect_clause]

### Starts the tutorial lesson with the given key. Does nothing if the tutorial is not running, the lesson is completed (or already running), or the lesson cannot be triggered (e.g. trigger fails)
alias[effect:start_tutorial_lesson] = {
    tutorial_lesson = <tutorial_lesson>
    ## cardinality = 0..1
    journal_entry = scope[journal_entry]
}

### Switch on a trigger for the evaluation of another trigger with an optional fallback trigger. switch = { 	trigger = simple_assign_trigger 	case_1 = { <effects> } 	case_2 = { <effects> } 	case_n = { <effects> } 	fallback = { <effects> }
alias[effect:switch] = {
    trigger = alias_keys_field[trigger]
    ## cardinality = 0..inf
	scalar = {
		## cardinality = 0..inf
		alias_name[effect] = alias_match_left[effect]
	}
}

### Triggers an event for the current scope trigger_event = X trigger_event = { id = X days/weeks/months/years = Y } Where X is an event ID and Y is an integer to delay the event by
alias[effect:trigger_event] = <event>

### Triggers an event for the current scope trigger_event = X trigger_event = { id = X days/weeks/months/years = Y } Where X is an event ID and Y is an integer to delay the event by
alias[effect:trigger_event] = {
    id = <event>
    ## cardinality = 0..1
    enum[duration] = int
    ## cardinality = 0..1
    enum[duration] = {
        ## cardinality = 1..inf
        int
    }
    ## cardinality = 0..1
    popup = bool
}


### Repeats enclosed effects while limit criteria are met or until set iteration count is reached while = { limit = { <triggers> } <effects> }  while = { count = 3 <effects> } Default max of 1000.
alias[effect:while] = {
    limit = {
        ## cardinality = 1..inf
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alias_name[effect] = alias_match_left[effect]
}

### Repeats enclosed effects while limit criteria are met or until set iteration count is reached while = { limit = { <triggers> } <effects> }  while = { count = 3 <effects> } Default max of 1000.
alias[effect:while] = {
    count = int
    ## cardinality = 0..inf
    alias_name[effect] = alias_match_left[effect]
}

# TODO: Is this <building> or scope[building]?
### Activate a building in a state activate_building = { building = building_key }
alias[effect:activate_building] = {
    building = <building>
}

### Apply a standard of living modifier in the scoped state for the given culture. Other than the required culture argument, this effect has the same syntax as add_modifier.
alias[effect:add_culture_standard_of_living_modifier] = {
    culture = scope[culture]
    ## cardinality = 0..1
    enum[duration] = int
    ## cardinality = 0..1
    multiplier = value_field
}

### Apply a standard of living modifier in the scoped state for the given religion. Other than the required religion argument, this effect has the same syntax as add_modifier.
alias[effect:add_religion_standard_of_living_modifier] = {
    religion = scope[religion]
    ## cardinality = 0..1
    enum[duration] = int
    ## cardinality = 0..1
    multiplier = value_field
}

### Changes X% of the different religion population to the specified religion. convert_population = { target = rel:catholic value = 0.5 }
alias[effect:convert_population] = {
    target = scope[religion]
    value = value_field
}

### Creates a building in the scoped state. Supported values are: 	building = <building> 	activate_production_methods = { <production_methods> } 	subsidized = yes/no 	reserves = [0..1] (percentage of cash reserves the building should be created with) 	level = arable_land/integer  If level is "arable_land", the building will be of the necessary level to exhaust all available arable land in the state. If level is "urbanization", the building will be of the necessary level to exhaust all available urbanzation in the state. If level is an integer, the building will be of that level  Please note: this effect works a little differently if there already is a building of the specified type in the state. If that happens: 	1. the level will be the maximum between the scripted level and the level of the existing building 	2. the cash reserves will be the maximum between the scripted value and the existing cash reserves
alias[effect:create_building] = {
    building = <building>
    ## cardinality = 0..1
    activate_production_methods = {
        ## cardinality = 0..inf
        <production_method>
    }
    ## cardinality = 0..1
    subsidized = bool
    ## cardinality = 0..1
    reserves = value_field[0..1]
    ## cardinality = 0..1
    level = int
    ## cardinality = 0..1
    level = arable_land
    ## cardinality = 0..1
    level = urbanization
}

### Creates a pop in the scoped state
alias[effect:create_pop] = {
    culture = <culture>
    size = int_value_field
    ## cardinality = 0..1
    pop_type = <pop_type>
    ## cardinality = 0..1
    religion = <religion>
}

### Deactivate a building in a state deactivate_building = { building = building_key }
alias[effect:deactivate_building] = {
    building = <building>
}

### Forces a resource depletion in state force_resource_depletion = bg_gold_mining
alias[effect:force_resource_depletion] = <building_group>

### Forces a resource discovery in state force_resource_discovery = bg_gold_mining
alias[effect:force_resource_discovery] = <building_group>

### Remove a building in the scope state remove_building = building_key
alias[effect:remove_building] = <building>

### Set State Owner set_state_owner = scope
alias[effect:set_state_owner] = scope[country]

### Sets a state to a certain type (incorporated, unincorporated, treaty_port)
alias[effect:set_state_type] = enum[state_type]

### Start constructing a building in a scoped state start_building_construction = building_barracks
alias[effect:start_building_construction] = <building>

### Add/remove arable land from a state region
alias[effect:add_arable_land] = int_value_field

### Adds scoped state region as a claim for target country add_claim = scope/country
alias[effect:add_claim] = scope[country]

### Add/remove devastation from a state region
alias[effect:add_devastation] = int_value_field

### Adds scoped state region as Homeland for target culture add_homeland = scope/culture
alias[effect:add_homeland] = <culture>

### Increase/decrease pollution level in a scoped state region add_pollution = 10
alias[effect:add_pollution] = int_value_field

### creates a state in a state region
alias[effect:create_state] = {
    country = scope[country]
    owned_provinces = {
        ## cardinality = 0..inf
        <province>
    }
}

### Removes scoped state region as a claim for target country add_claim = scope/country
alias[effect:remove_claim] = scope[country]

### Removes scoped state region as Homeland for target culture add_homeland = scope/culture
alias[effect:remove_homeland] = scope[culture]
### Removes scoped state region as Homeland for target culture add_homeland = scope/culture
alias[effect:remove_homeland] = <culture>

### Set devastation to a state region
alias[effect:set_devastation] = int_value_field

### Gives a set of provinces in a state region to a specific country set_owner_of_provinces = { country = <scope> provinces = {} }
alias[effect:set_owner_of_provinces] = {
    country = scope[country]
    provinces = {
        ## cardinality = 0..inf
        <province>
    }
}

### Sets a (new) target technology scope for a journal entry set_target_technology = <scope>
alias[effect:set_target_technology] = scope[technology]

### Activates a law for a country
alias[effect:activate_law] = scope[law_type]

### Adds a total ban of a good to a country add_banned_goods = <goods key/scope>
alias[effect:add_banned_goods] = scope[goods]

### Add progress towards changing relations between two countries add_change_relations_progress = { 	tcountry = country scope/tag 	value = amount }
alias[effect:add_change_relations_progress] = {
    country = scope[country]
    country = <country_definition>
    value = value_field
}

### Will create a declared interest in the target strategic region c:FRA = { add_declared_interest = region_nile_basin }
alias[effect:add_declared_interest] = <strategic_region>

### Adds an enactment-related timed modifier effect to object in scope
alias[effect:add_enactment_modifier] = {
    name = <modifier_container>
    ## cardinality = 0..1
    multiplier = value_field
}

### Add specified era as researched in a country scope add_era_researched = era
alias[effect:add_era_researched] = <era>

### Directly adds money to the investment pool add_investment_pool = 50
alias[effect:add_investment_pool] = int_value_field

### Adds x% progress to the current checkpoint of the law being passed (range is [0, 1], 0.1 means 10 percentage points) add_law_progress = 0.1 / -0.1
alias[effect:add_law_progress] = value_field[-1..1]

### Adds a culture to the primary cultures of a country add_primary_culture = X Where X is a culture scope
alias[effect:add_primary_culture] = scope[culture]

### Adds consumption taxes on a good to a country add_taxed_goods = <goods key/scope>
alias[effect:add_taxed_goods] = scope[goods]

### Add technology progress add_technology_progress = { progress = X technology = Y } Where X is a fixed point and Y is an technology
alias[effect:add_technology_progress] = {
    technology = <technology>
    progress = value_field
}

### Research the specified technology in a country scope add_technology_researched = technology
alias[effect:add_technology_researched] = <technology>

### Add/remove money from a country add_treasury = fixed point
alias[effect:add_treasury] = value_field

### Annexes a country annex = scope
alias[effect:annex] = scope[country]

### Sets the next election date for country in N months call_election = { 	months = 6 }
alias[effect:call_election] = single_alias_right[duration_clause]

### Add/remove the investment level for the institution change_institution_investment_level = {  	institution = institution_police 	investment = -1 }
alias[effect:change_institution_investment_level] = {
    institution = <institution>
    investment = int_value_field
}

### Change relations between two countries change_relations = { 	tcountry = country scope/tag 	value = amount }
alias[effect:change_relations] = {
    country = scope[country]
    country = <country_definition>
    value = value_field
}

### Will change the subject type of the country that is the current scope. change_subject_type = subject_type_dominion
alias[effect:change_subject_type] = <subject_type>

### Change the tag for the scoped country c:GBR = { change_tag = FRA }
alias[effect:change_tag] = <country_definition>

### Change tension between two countries change_tension = { 	tcountry = country scope/tag 	value = amount }
alias[effect:change_tension] = {
    country = scope[country]
    country = <country_definition>
    value = value_field
}

### Clear country loans = bool
alias[effect:clear_debt] = bool

### Clears an amount of debt equal to the defined multiplier on target's max credit clear_scaled_debt = value
alias[effect:clear_scaled_debt] = value_field

### Completes an objective subgoal complete_objective_subgoal = <key>
alias[effect:complete_objective_subgoal] = <objective_subgoal>

### Creates a character, any option can be omitted. create_character = { 	name = loc_key or alternatively first_name and last_name separately 	culture = culture_tag 	religion = religion scope (if omitted, it's defined by the character's culture religion) 	female = bool or character scope (gets the same value from the character) 	noble = bool or character scope (gets the same value from the character) 	ruler = bool or character scope (gets the same value from the character) 	heir = bool 	age = integer, range, or character scope (gets the age from a character) 	ideology = ideology key or scope 	interest_group = interest group key or scope 	on_created = effect	trait_generation = effect	role = character scope (gets the role from a character) 	hq = HQ scope or strategic region scope }
alias[effect:create_character] = {
    ## cardinality = 0..1
    name = localisation
    ## cardinality = 0..1
    first_name = localisation
    ## cardinality = 0..1
    last_name = localisation

    ## cardinality = 0..1
    culture = <culture>
    ## cardinality = 0..1
    culture = scope[culture]

    ## cardinality = 0..1
    religion = <religion>
    ## cardinality = 0..1
    religion = scope[religion]

    ## cardinality = 0..1
    female = bool
    ## cardinality = 0..1
    female = scope[character]

    ## cardinality = 0..1
    heir = bool

    ## cardinality = 0..1
    age = int_value_field
    ## cardinality = 0..1
    age = scope[character]

    ## cardinality = 0..1
    birth_date = date_field

    ## cardinality = 0..1
    ideology = <ideology>
    ## cardinality = 0..1
    ideology = scope[ideology]

    ## cardinality = 0..1
    interest_group = <interest_group>
    ## cardinality = 0..1
    interest_group = scope[interest_group]

    ## cardinality = 0..1
    ig_leader = bool

    ## cardinality = 0..1
    is_general = bool

    ## cardinality = 0..1
    is_admiral = bool

    ## cardinality = 0..1
    commander_rank = <commander_rank>
    ## cardinality = 0..1
    commander_rank = default

    ## cardinality = 0..1
    ruler = bool
    ## cardinality = 0..1
    ruler = scope[character]

    ## cardinality = 0..1
    noble = bool
    ## cardinality = 0..1
    noble = scope[character]

    ## cardinality = 0..1
    on_created = single_alias_right[effect_clause]

    ## cardinality = 0..1
    trait_generation = single_alias_right[effect_clause]

    ## cardinality = 0..1
    traits = {
        ## cardinality = 0..inf
        <character_trait>
    }

    ## cardinality = 0..1
    role = scope[character]

    #TODO add hq scope?
    ## cardinality = 0..1
    hq = scope[strategic_region]
    ## cardinality = 0..1
    hq = <strategic_region>

    ## cardinality = 0..1
    dna = <dna_data>

    ## cardinality = 0..1
    template = <character_template>
    ## cardinality = 0..1
    save_scope_as = value_set[event_target]
}

### Create a diplomatic pact between two countries, with scope country as initiator create_diplomatic_pact = { 	tcountry = country scope/tag 	type = diplomatic action type }
alias[effect:create_diplomatic_pact] = {
    country = scope[country]
    country = <country_definition>
    type = <diplomatic_action>
}

### Create a diplomatic play with the scoped object as target create_diplomatic_play = { 	name = loc_key 	escalation = integer between 0 and 100 	war = bool 	initiator = country scope/tag 	type = diplomatic play type 	add_initiator_backers = { list of country scopes/tags } 	add_target_backers = { list of country scopes/tags } 	add_war_goal = { holder = country scope/tag, type = x, state = <state target>, country = <country target,> region = <region target>  } }
alias[effect:create_diplomatic_play] = {
    ## cardinality = 0..1
    name = localisation
    ## cardinality = 0..1
    escalation = int_value_field[0..100]

    ## cardinality = 0..1
    war = no
    ## cardinality = 0..1
    initiator = scope[country]
    ## cardinality = 0..1
    initiator = <country_definition>

    type = <diplomatic_play>

    ## cardinality = 0..1
    target_state = scope[state]
    ## cardinality = 0..1
    target_country = scope[country]
    ## cardinality = 0..1
    target_region = scope[state_region]


    ## cardinality = 0..1
    add_initiator_backers = {
        ## cardinality = 0..inf
        scope[country]
        ## cardinality = 0..inf
        <country_definition>
    }

    ## cardinality = 0..1
    add_target_backers = {
        ## cardinality = 0..inf
        scope[country]
        ## cardinality = 0..inf
        <country_definition>
    }
}

### Create a diplomatic play with the scoped object as target create_diplomatic_play = { 	name = loc_key 	escalation = integer between 0 and 100 	war = bool 	initiator = country scope/tag 	type = diplomatic play type 	add_initiator_backers = { list of country scopes/tags } 	add_target_backers = { list of country scopes/tags } 	add_war_goal = { holder = country scope/tag, type = x, state = <state target>, country = <country target,> region = <region target>  } }
alias[effect:create_diplomatic_play] = {
    ## cardinality = 0..1
    name = localisation
    ## cardinality = 0..1
    escalation = int_value_field[0..100]

    war = yes
    ## cardinality = 0..1
    initiator = scope[country]
    ## cardinality = 0..1
    initiator = <country_definition>

    type = <diplomatic_play>

    ## cardinality = 0..1
    target_state = scope[state]
    ## cardinality = 0..1
    target_country = scope[country]
    ## cardinality = 0..1
    target_region = scope[state_region]

    ## cardinality = 0..1
    add_initiator_backers = {
        ## cardinality = 0..inf
        scope[country]
        ## cardinality = 0..inf
        <country_definition>
    }

    ## cardinality = 0..1
    add_target_backers = {
        ## cardinality = 0..inf
        scope[country]
        ## cardinality = 0..inf
        <country_definition>
    }

    ## cardinality = 1..inf
    add_war_goal = {
        holder = scope[country]
        holder = <country_definition>
        type = enum[war_goal]

        ## cardinality = 0..1
        target_state = scope[state]
        ## cardinality = 0..1
        target_country = scope[country]
        ## cardinality = 0..1
        target_region = scope[state_region]
    }
}

### Creates a diplomatic incident that generates infamy, with target country as the victim create_incident = { 	tcountry = country scope/tag 	value = infamy amount }
alias[effect:create_incident] = {
    country = scope[country]
    country = <country_definition>
    value = value_field
}

### Creates a new Trade Route trade_route = { 	goods = x 	level = x 	import = yes/no 	origin = state_region 	target = state_region }
alias[effect:create_trade_route] = {
    goods = <goods>
    level = int_value_field
    ## cardinality = 0..1
    import = bool
    ## cardinality = 0..1
    origin = scope[market]
    #TODO: market?
    target = scope[state_region]
    direction = import
    direction = export
}

### Create a truce betweeen two countries create_truce = { 	tcountry = country scope/tag 	months = integer }
alias[effect:create_truce] = {
    country = scope[country]
    country = <country_definition>
    months = int_value_field
}

### Deactivates a law for a country
alias[effect:deactivate_law] = scope[law_type]

### Deactivates parties in scoped country. deactivate_parties = yes
alias[effect:deactivate_parties] = yes

### Ends a truce betweeen two countries end_truce = { 	tcountry = country scope/tag 	months = integer }
alias[effect:end_truce] = replace_me

### Makes a country independent. make_independent = bool
alias[effect:make_independent] = bool

### Change which country scoped country's player will play as play_as = <scope>
alias[effect:play_as] = scope[country]

### Recalculates and updates a country's pop IG memberships = bool
alias[effect:recalculate_pop_ig_support] = bool

### Removes an active objective subgoal remove_active_objective_subgoal = <key>
alias[effect:remove_active_objective_subgoal] = <objective_subgoal>

### Removes a total ban of a good from a country remove_banned_goods = <goods key/scope>
alias[effect:remove_banned_goods] = scope[goods]

### Removes a diplomatic pact between two countries, with scope country as initiator remove_diplomatic_pact = { 	country = country scope/tag 	type = diplomatic action type }
alias[effect:remove_diplomatic_pact] = {
    country = scope[country]
    country = <country_definition>
    type = <diplomatic_action>
}

### Removes an enactment-related timed modifier effect to object in scope
alias[effect:remove_enactment_modifier] = replace_me

### Removes a culture from the primary cultures of a country remove_primary_culture = X Where X is a culture scope
alias[effect:remove_primary_culture] = scope[culture]

### Removes consumption taxes on a good from a country remove_taxed_goods = <goods key/scope>
alias[effect:remove_taxed_goods] = scope[goods]

### Set capital state in a country scope set_capital = X Where X is a state region
alias[effect:set_capital] = <state_region>

### Sets the type of country for a country, for history
alias[effect:set_country_type] = enum[country_type]

### Set diplomats expelled = bool
alias[effect:set_diplomats_expelled] = bool

### Sets the government wage level of scoped country set_government_wage_level = very_low/low/medium/high/very_high
alias[effect:set_government_wage_level] = enum[wage_level]

### Sets the investment level for an institution set_institution_investment_level = { institution = <key> level = x }
alias[effect:set_institution_investment_level] = {
    institution = <institution>
    level = int_value_field
}

### Set market capital in a country scope set_market_capital = X Where X is a state region
alias[effect:set_market_capital] = <state_region>

### Sets the military wage level of scoped country set_military_wage_level = very_low/low/medium/high/very_high
alias[effect:set_military_wage_level] = enum[wage_level]

### Set mutual secret AI goal for scope country and target country set_mutual_secret_goal = { 	tcountry = country scope/tag 	secret_goal = secret goal type }
alias[effect:set_mutual_secret_goal] = {
    country = scope[country]
    country = <country_definition>
    secret_goal = enum[secret_goal]
}

### Set next election date for country set_next_election_date = year.month.day
alias[effect:set_next_election_date] = date_field

### Set whether a country owes another a obligation set_owes_obligation = { 	country = country scope/tag 	setting = yes/no }
alias[effect:set_owes_obligation_to] = {
    country = scope[country]
    country = <country_definition>
    setting = bool
}

### Set relations between two countries set_relations = { 	tcountry = country scope/tag 	value = amount }
alias[effect:set_relations] = {
    country = scope[country]
    country = <country_definition>
    value = int_value_field
}

### Creates a government for the country in scope from a set of interest groups set_ruling_interest_groups = { ig_tag1 ig_tag2 }
alias[effect:set_ruling_interest_groups] = {
    ## cardinality = 1..*
    <interest_group>
}

### Set a secret AI goal for scope country towards another country set_secret_goal = { 	tcountry = country scope/tag 	secret_goal = secret goal type }
alias[effect:set_secret_goal] = {
    country = scope[country]
    country = <country_definition>
    secret_goal = enum[secret_goal]
}

### Changes the state religion of the country to the specified religion set_state_religion = X Where X is a religion scope
alias[effect:set_state_religion] = scope[religion]

### Set AI strategy for scope country set_strategy = <key>
alias[effect:set_strategy] = <ai_strategy>

### Sets Export Prioritized tariffs for a good in scoped country set_tariffs_export_priority = <scope/key>
alias[effect:set_tariffs_export_priority] = scope[goods]

### Sets Import Prioritized tariffs for a good in scoped country set_tariffs_import_priority = <scope/key>
alias[effect:set_tariffs_import_priority] = scope[goods]

### Sets tariffs to have no import/export priority for a good in scoped country set_tariffs_no_priority = <scope/key>
alias[effect:set_tariffs_no_priority] = scope[goods]

### Sets the overall tax level of scoped country set_tax_level = very_low/low/medium/high/very_high
alias[effect:set_tax_level] = enum[wage_level]

### Set tension between two countries set_tension = { 	tcountry = country scope/tag 	value = amount }
alias[effect:set_tension] = {
    country = scope[country]
    country = <country_definition>
    value = value_field
}

### Scoped country starts research of any random technology they can start_research_random_technology = yes
alias[effect:start_research_random_technology] = yes

### Transfers an amount of debt equal to the defined multiplier on target's max credit take_on_scaled_debt = { 	who = <country> 	value = decimal value }
alias[effect:take_on_scaled_debt] = {
    who = scope[country]
    value = value_field
}

### Updates party support in scoped country. update_party_support = yes
alias[effect:update_party_support] = yes

### Validates subsidies across a country's buildings. validate_subsidies = bool
alias[effect:validate_subsidies] = bool

### Target joins scoped war violate_sovereignty_accept = <country>
alias[effect:violate_sovereignty_join] = {
    violator = scope[country]
    target = scope[country]
    join_violator = bool
}

### Activates the named production method for buildings of a certain type in country/state
alias[effect:activate_production_method] = {
    building_type = <building>
    production_method = <production_method>
}

### Adds loyalists to pops in state or country, all parameters except value are optional add_loyalists = { value = x pop_type = <key> strata = <key> culture = <scope/cu:key> religion = <scope/rel:key> }
alias[effect:add_loyalists] = {
    value = value_field
    ## cardinality = 0..1
    pop_type = <pop_type>
    ## cardinality = 0..1
    strata = enum[pop_strata]
    ## cardinality = 0..1
    culture = scope[culture]
    ## cardinality = 0..1
    religion = scope[religion]
}

### Adds radicals to pops in state or country, all parameters except value are optional add_radicals = { value = x pop_type = <key> strata = <key> culture = <scope/cu:key> religion = <scope/rel:key> }
alias[effect:add_radicals] = {
    value = value_field
    ## cardinality = 0..1
    pop_type = <pop_type>
    ## cardinality = 0..1
    strata = enum[pop_strata]
    ## cardinality = 0..1
    culture = scope[culture]
    ## cardinality = 0..1
    religion = scope[religion]
}

### Adds the wealth of the pop add_pop_wealth = { wealth_distribution = {...} update_loyalties = true/false } Where the distribution adding to wealth of the pop
alias[effect:add_pop_wealth] = replace_me

### Changes the culture of the scoped pop to a specified culture by a specified percentage change_pop_culture = { target = cu:spanish value = 0.33 }
alias[effect:change_pop_culture] = {
    target = scope[culture]
    value = value_field
}

### Changes the religion of the scoped pop to a specified religion by a specified percentage change_pop_religion = { target = rel:catholic value = 0.5 }
alias[effect:change_pop_religion] = {
    target = scope[religion]
    value = value_field
}

### Changes the type of the pop to the given type
alias[effect:change_poptype] = scope[pop_type]

### Moves the scoped pop to the specified state (they become unemployed) move_pop = s:STATE_TUSCANY.region_state:TUS  NOTE: VERY IMPORTANT! This effect _may_ change the pop type of the moved pop. This will happen under the following conditions: 1. if the current pop type cannot be unemployed, the new pop type will be the default one 2.if the current pop type is a slave type and the target state does not allow slavery, the new pop type will be the default one
alias[effect:move_pop] = scope[state]

### Sets the literacy of the pop set_pop_literacy = { literacy_rate = {...} } Where the ratio is a script value computing the percentage of (workforce) pops that will be literate
alias[effect:set_pop_literacy] = {
    literacy_rate = value_field
}

### Sets the pop qualifications of the pop for the given type set_pop_qualifications = { pop_type = {} qualifications = {...} } Where the qualifications is a script value computing the percentage of (workforce) pops that will have the qualifications
alias[effect:set_pop_qualifications] = replace_me

### Sets the wealth of the pop set_pop_wealth = { wealth_distribution = {...} update_loyalties = true/false } Where wealth is a script values
alias[effect:set_pop_wealth] = {
    wealth_distribution = value_field
    ## cardinality = 0..1
    update_loyalties = bool
}

### Adds war support to the target country in the scoped diplomatic play. The amount will appear under the 'situations' header in tooltips add_diplomatic_play_war_support = { target = country value = value }
alias[effect:add_diplomatic_play_war_support] = replace_me

### Add escalation to a diplomatic play add_escalation = integer
alias[effect:add_escalation] = int_value_field

### Add a tag/scope country to the initiator side of a diplomatic play add_initiator_backers = { list of scopes/tags }
alias[effect:add_initiator_backers] = {
    ## cardinality = 1..inf
    scope[country]
}

### Add a tag/scope country to the target side of a diplomatic play add_target_backers = { list of scopes/tags }
alias[effect:add_target_backers] = {
    ## cardinality = 1..inf
    scope[country]
}

### Adds a war goal to a DP. Same data read in as add_war_goal in create_diplomatic_play random_diplomatic_play = { add_war_goal = { holder = initiator type = secession }
alias[effect:add_war_goal] = {
    holder = scope[country]
    type = enum[war_goal]
}

### End a diplomatic play end_play = bool
alias[effect:end_play] = bool

### Remove a tag/scope country from the initiator side of a diplomatic play remove_initiator_backers = { list of scopes/tags }
alias[effect:remove_initiator_backers] = {
    ## cardinality = 1..inf
    scope[country]
}

### Remove a tag/scope country to the target side of a diplomatic play remove_target_backers = { list of scopes/tags }
alias[effect:remove_target_backers] = {
    ## cardinality = 1..inf
    scope[country]
}

### Removes a war goal from a DP if there's at least one other war goal present. any_diplomatic_play = { limit = { has_war_goal = return_state } remove_war_goal = { who = initiator war_goal = return_state } }
alias[effect:remove_war_goal] = {
    who = scope[country]
    war_goal = enum[war_goal]
}

### effect end diplo play for one side, with it gaining war goals resolve_play_for = initiator resolve_play_for = scope:custom_scoped_country
alias[effect:resolve_play_for] = scope[country]

### Set name to a diplomatic play set_key = loc_key
alias[effect:set_key] = localisation

### Set a diplomatic play to be a war set_war = bool
alias[effect:set_war] = bool

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:round_global_variable] = {
    name = value[global_variable]
    nearest = value_field
}

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:round_local_variable] = {
    name = value[local_variable]
    nearest = value_field
}

### Saves the current scope as an arbitrarily-named temporary target to be referenced later in the same effect save_temporary_event_target_as = <string>
alias[effect:save_temporary_scope_as] = value_set[temporary_scope]

