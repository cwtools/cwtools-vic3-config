
### Sets whether a building is subsidized set_subsidized = yes/no
alias[effect:set_subsidized] = bool

### Adds the specified number of percentage points to a civil war progress (range is [0, 1], 0.1 means 10 percentage points) add_civil_war_progress = 0.1 / -0.1
alias[effect:add_civil_war_progress] = value_field[-1..1]

### Adds war exhaustion to the target country in the scoped war. The amount will appear under the 'situations' header in tooltips add_war_exhaustion = { target = country value = value }
alias[effect:add_war_exhaustion] = {
    target = scope[country]
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Adds war support to the target country in the scoped war. The amount will appear under the 'situations' header in tooltips add_war_war_support = { target = country value = value }
alias[effect:add_war_war_support] = {
    target = scope[country]
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Adds a new obsession to the culture in scope add_cultural_obsession = X Where X is a goods
alias[effect:add_cultural_obsession] = <good>

### Removes a new obsession to the culture in scope remove_cultural_obsession = X Where X is a goods
alias[effect:remove_cultural_obsession] = <good>

### Adds a new role to a character add_character_role = general
alias[effect:add_character_role] = enum[character_role]

### Promotes/demotes a character a given amount of military ranks
alias[effect:add_commander_rank] = int_value_field

### Adds an amount of experience to a commander add_experience = 0.2
alias[effect:add_experience] = value_field

### Adds a random qualifying Trait of the specified category add_random_trait = personality / skill / condition
alias[effect:add_random_trait] = enum[character_trait_type]

### Add a trait to a Character add_trait = trait
alias[effect:add_trait] = <character_trait>

### Changes the religion of the scoped character change_character_religion = rel:protestant
alias[effect:change_character_religion] = scope[religion]

### Frees a character from the void, if set to no character is deleted instead free_character_from_void = yes
alias[effect:free_character_from_void] = bool

### Kill a character kill_character = bool
alias[effect:kill_character] = bool
### Kill a character kill_character = { hidden = bool (yes - without notification; no - show notification [by default]) value = bool (yes - kill [by default], no - don't do anything)}
alias[effect:kill_character] = {
    ## cardinality = 0..1
    hidden = bool
    ## cardinality = 0..1
    value = bool
}

### Banishes a character to the void, duration is how long character is kept before being deleted place_character_in_void = months
alias[effect:place_character_in_void] = int_value_field

### Removes a character from position as interest group leader remove_as_interest_group_leader = yes
alias[effect:remove_as_interest_group_leader] = yes

### Remove a trait from a Character remove_trait = trait
alias[effect:remove_trait] = <character_trait>

### Sets a character as interest group leader set_as_interest_group_leader = yes
alias[effect:set_as_interest_group_leader] = yes

### Promotes/demotes a character to a given military rank value set_commander_rank = 3
alias[effect:set_commander_rank] = int_value_field

### Changes scoped character's ideology set_ideology = x
alias[effect:set_ideology] = scope[ideology]

### Transfers a Character to Country
alias[effect:transfer_character] = scope[country]

### Adds a timed modifier effect to object in scope
alias[effect:add_modifier] = {
    name = <modifier_container>
    ## cardinality = 0..1
    enum[duration] = int
    ## cardinality = 0..1
    enum[duration] = <script_value>
    ## cardinality = 0..1
    enum[duration] = <static_value>
    ## cardinality = 0..1
    enum[duration] = enum[duration]
    ## cardinality = 0..1
    multiplier = value_field
    ## cardinality = 0..1
    multiplier = <script_value>
    ## cardinality = 0..1
    multiplier = <static_value>
    ## cardinality = 0..1
    multiplier = single_alias_right[formula]
    ## cardinality = 0..1
    is_decaying = bool
}

### Adds a timed modifier effect to object in scope
alias[effect:add_modifier] = <modifier_container>

### Removes a timed modifier effect to object in scope
alias[effect:remove_modifier] = <modifier_container>

### Removes interest group from revolution abandon_revolution = yes/no
alias[effect:abandon_revolution] = bool

### Adds an ideology to scoped interest group add_ideology = x
alias[effect:add_ideology] = <ideology>

### Adds interest group to government add_ruling_interest_group = yes/no
alias[effect:add_ruling_interest_group] = bool

### Adds interest group to ongoing revolution join_revolution = yes/no
alias[effect:join_revolution] = bool

### Removes an ideology from scoped interest group remove_ideology = x
alias[effect:remove_ideology] = <ideology>

### Removes interest group in scope from government remove_ruling_interest_group = yes/no
alias[effect:remove_ruling_interest_group] = bool

### Starts/stops bolstering the interest group in scope set_ig_bolstering = yes/no
alias[effect:set_ig_bolstering] = bool

### Starts/stops suppressing the interest group in scope set_ig_suppression = yes/no
alias[effect:set_ig_suppression] = bool

### Renames interest group to the specified loc key set_interest_group_name = x
alias[effect:set_interest_group_name] = localisation

### Checks if a pop has a certain amount of wealth wealth = value
alias[effect:set_ig_trait] = scope[interest_group]

### Lock a trade route for a set amount of time, preventing it from being cancelled manually lock_trade_route = { 	years = 5 }
alias[effect:lock_trade_route] = {
    enum[duration] = int
}

### Adds momentum to a Party during a campaign period dd_momentum = value
alias[effect:add_momentum] = value_field
### Adds momentum to a Party during a campaign period dd_momentum = value
alias[effect:add_momentum] = <scipt_valie>
### Adds momentum to a Party during a campaign period dd_momentum = value
alias[effect:add_momentum] = <static_value>

### Adds a journal entry to a scoped country's journal, with optional saved scope target add_journal_entry = { type = <key> target = <scope> }
alias[effect:add_journal_entry] = {
    type = <journal_entry>
    ## cardinality = 0..1
    target = scope_field
    ## cardinality = 0..1
    objective_subgoal = <objective_subgoal>
}

### Adds the event target to a variable list add_to_variable_list = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:add_to_global_variable_list] = {
    name = value_set[global_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the (unbroken) event chain add_to_list = <string> NOTE, if adding a permanent target to a temporary list, the whole list becomes permanent
alias[effect:add_to_list] = value_set[list]

### Adds the event target to a variable list add_to_variable_list = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:add_to_local_variable_list] = {
    name = value_set[local_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the same effect add_to_temporary_list = <string> NOTE, if adding a temporary target to a permanent list, the list will stay permanent
alias[effect:add_to_temporary_list] = value_set[temporary_list]

### Adds the event target to a variable list add_to_variable_list = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:add_to_variable_list] = {
    name = value_set[variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Conditionally cause an assert during run time assert_if = { limit = { X } text = Y }, where X is a trigger and Y is an optional string
alias[effect:assert_if] = {
    limit = {
        ## cardinality = 1..inf
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    text = localisation
}

### Conditionally cause an assert during read time assert_read = X, where X is yes or the string to be printed in the assert
alias[effect:assert_read] = yes

### Conditionally cause an assert during read time assert_read = X, where X is yes or the string to be printed in the assert
alias[effect:assert_read] = scalar

### Changes the value or a numeric variable change_variable = { name = X operation = Y } Where X is the name of the numeric variable to modify Where the valid operations are add, subtract, multiply, divide and modulo Where Y is a fixed point value, script value or event target of a value type
alias[effect:change_global_variable] = {
    name = value[global_variable]
    alias_name[arithmetic_operation] = alias_match_left[arithmetic_operation]
}

### Change infamy of scope country change_infamy = amount
alias[effect:change_infamy] = value_field
alias[effect:change_infamy] = single_alias_right[formula]
alias[effect:change_infamy] = <script_value>
alias[effect:change_infamy] = <static_value>
alias[effect:change_infamy] = $define_reference

### Changes the value or a numeric variable change_variable = { name = X operation = Y } Where X is the name of the numeric variable to modify Where the valid operations are add, subtract, multiply, divide and modulo Where Y is a fixed point value, script value or event target of a value type
alias[effect:change_local_variable] = {
    name = value[local_variable]
    alias_name[arithmetic_operation] = alias_match_left[arithmetic_operation]
}

### Changes the value or a numeric variable change_variable = { name = X operation = Y } Where X is the name of the numeric variable to modify Where the valid operations are add, subtract, multiply, divide and modulo Where Y is a fixed point value, script value or event target of a value type
alias[effect:change_variable] = {
    name = value[variable]
    alias_name[arithmetic_operation] = alias_match_left[arithmetic_operation]
}

alias[effect:kill_population] = {
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference

    ## cardinality = 0..1
    pop_type = <pop_type>

    ## cardinality = 0..1
    religion = scope[religion]

    ## cardinality = 0..1
    culture = scope[culture]

    ## cardinality = 0..1
    strata = enum[pop_strata]
}

### Clamps a variable the specified max and min clamp_variable = { name = X max = Y min = Z } Where X is the name of the variable Where Y and Z are script values
alias[effect:clamp_global_variable] = {
    name = value[global_variable]
    min = value_field
    min = single_alias_right[formula]
    min = <script_value>
    min = <static_value>
    min = $define_reference
    max = value_field
    max = single_alias_right[formula]
    max = <script_value>
    max = <static_value>
    max = $define_reference
}

### Clamps a variable the specified max and min clamp_variable = { name = X max = Y min = Z } Where X is the name of the variable Where Y and Z are script values
alias[effect:clamp_local_variable] = {
    name = value[local_variable]
    min = value_field
    min = single_alias_right[formula]
    min = <script_value>
    min = <static_value>
    min = $define_reference
    max = value_field
    max = single_alias_right[formula]
    max = <script_value>
    max = <static_value>
    max = $define_reference
}

### Clamps a variable the specified max and min clamp_variable = { name = X max = Y min = Z } Where X is the name of the variable Where Y and Z are script values
alias[effect:clamp_variable] = {
    name = value[variable]
    min = value_field
    min = single_alias_right[formula]
    min = <script_value>
    min = <static_value>
    min = $define_reference
    max = value_field
    max = single_alias_right[formula]
    max = <script_value>
    max = <static_value>
    max = $define_reference
}

### Empties the list clear_variable_list = variable_name
alias[effect:clear_global_variable_list] = value[global_variable_list]

### Empties the list clear_variable_list = variable_name
alias[effect:clear_local_variable_list] = value[local_variable_list]

### Clears a saved scope from the top scope save_scope_as = cool_scope -> clear_saved_scope = cool_scope
alias[effect:clear_saved_scope] = value[event_target]

### Empties the list clear_variable_list = variable_name
alias[effect:clear_variable_list] = value[variable_list]

### Creates a new country create_country = { 	tag = TAG			# optional, if not specified origin's tag will be used 	origin = country	# optional, newly created country will inherit certain values from the origin country 	                    # at least one of tag or origin must be supplied 	state = state		# can be repeated; at least one state or province must be supplied 	province = province	# can be repeated; at least one state or province must be supplied 						# both states and provinces can be supplied at the same time 	on_created = effect	# optional effect that will be run with the newly created country in scope }
alias[effect:create_country] = {
    ## cardinality = 0..1
    tag = <country_definition>
    ## cardinality = 0..1
    origin = scope[country]
    ## cardinality = 0..inf
    state = scope[state]
    ## cardinality = 0..inf
    province = scope[province]
    ## push_scope = country
    ## cardinality = 0..1
    on_created = single_alias_right[effect_clause]
}

### Wraps effects that get a custom description instead of the auto-generated one custom_description = { 	text = <effect_localization_key> 	subject = <optional subject scope> #defaults to current scope 	object = <optional object scope> 	value = <optional script value> 	... effects ... }
alias[effect:custom_description] = {
    text = localisation
    ## cardinality = 0..1
    subject = scope_field
    ## cardinality = 0..1
    object = scope_field
    ## cardinality = 0..1
    value = value_field
    ## cardinality = 0..1
    value = single_alias_right[formula]
    ## cardinality = 0..1
    value = <script_value>
    ## cardinality = 0..1
    value = <static_value>
    ## cardinality = 0..1
    value = $define_reference
    alias_name[effect] = alias_match_left[effect]    
}

### Wraps effects that get a custom description instead of the auto-generated one. Also ensures no bullet point appears custom_description_no_bullet = { 	text = <effect_localization_key> 	subject = <optional subject scope> #defaults to current scope 	object = <optional object scope> 	value = <optional script value> 	... effects ... }
alias[effect:custom_description_no_bullet] = {
    text = localisation
    ## cardinality = 0..1
    subject = scope_field
    ## cardinality = 0..1
    object = scope_field
    ## cardinality = 0..1
    value = value_field
    ## cardinality = 0..1
    value = single_alias_right[formula]
    ## cardinality = 0..1
    value = <script_value>
    ## cardinality = 0..1
    value = <static_value>
    ## cardinality = 0..1
    value = $define_reference
    alias_name[effect] = alias_match_left[effect]    
}

### just a tooltip, the scope as object (for grouping, localization). Can also be written as custom_label = { text = key subject = scope (optional) <hidden effects> }
alias[effect:custom_label] = localisation

### just a tooltip, the scope as subject (for grouping, localization). Can also be written as custom_tooltip = { text = key subject = scope (optional) <hidden effects> }
alias[effect:custom_tooltip] = localisation
### just a tooltip, the scope as subject (for grouping, localization). Can also be written as custom_tooltip = { text = key subject = scope (optional) <hidden effects> }
alias[effect:custom_tooltip] = {
    text = localisation
    ## cardinality = 0..1
    subject = scope_field
    alias_name[effect] = alias_match_left[effect]
}

### Log a string to the debug log when this effect executes, debug_log = message, the message can be a localization string with ROOT, SCOPE and PREV available
alias[effect:debug_log] = scalar

### Log a string to the debug log when this effect executes, debug_log = message, the message can be a localization string with ROOT, SCOPE and PREV available
alias[effect:debug_log] = localisation

### Log the current scope to the debug log when this effect executes yes = full scope info, no=only current scope
alias[effect:debug_log_scopes] = bool

### Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met if = { limit = { <triggers> } <effects> } else = { <effects> }
alias[effect:else] = {
    ## cardinality = 1..inf
    alias_name[effect] = alias_match_left[effect]
}

### Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met, and its own limit is met if = { limit = { <triggers> } <effects> } else_if = { limit = { <triggers> } <effects> }
alias[effect:else_if] = {
    ## cardinality = 0..1
    limit = { alias_name[trigger] = alias_match_left[trigger] }
    alias_name[effect] = alias_match_left[effect]
}

### Effect not shown in tooltips
alias[effect:hidden_effect] = {
    ## cardinality = 1..inf
    alias_name[effect] = alias_match_left[effect]
}

### Executes enclosed effects if limit criteria are met if = { limit = { <triggers> } <effects> }
alias[effect:if] = {
    ## cardinality = ~1..1
    limit = { alias_name[trigger] = alias_match_left[trigger] }
    alias_name[effect] = alias_match_left[effect]
}

### Posts notification
alias[effect:post_notification] = <message>

### Posts proposal
alias[effect:post_proposal] = <proposal_type>

### a random effect, random = { chance = X modifier = Y effects... } where X is a chance of the enclosed effects being fired and can be modified by optional value modifier list (AKA MTTH) Y
alias[effect:random] = {
    chance = int_value_field[1...99]
    ## cardinality = 0..inf
    modifier = single_alias_right[formula]
    ## cardinality = 1..inf
    alias_name[effect] = alias_match_left[effect]
}

### Removes the current scope from a named list remove_from_list = <string>
alias[effect:remove_from_list] = value[list]

### Removes a variable remove_variable = variable_name
alias[effect:remove_global_variable] = value[global_variable]

### Removes the target from a variable list remove_list_variable = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:remove_list_global_variable] = {
    name = value[global_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Removes the target from a variable list remove_list_variable = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:remove_list_local_variable] = {
    name = value[local_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Removes the target from a variable list remove_list_variable = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:remove_list_variable] = {
    name = value[variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Removes a variable remove_variable = variable_name
alias[effect:remove_local_variable] = value[local_variable]

### Removes a variable remove_variable = variable_name
alias[effect:remove_variable] = value[variable]

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:remove_global_variable] = value[global_variable]

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:remove_local_variable] = value[local_variable]

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:round_variable] = {
    name = value[variable]
    nearest = value_field
}

### Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain save_event_target_as = <string>
alias[effect:save_scope_as] = value_set[event_target]

### Saves a numerical or bool value as an arbitrarily-named target to be referenced later in the (unbroken) event chain save_scope_value_as = { name = <string> value = x }
alias[effect:save_scope_value_as] = {
    name = value_set[event_target]
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Saves the current scope as an arbitrarily-named temporary target to be referenced later in the same effect save_temporary_event_target_as = <string>
alias[effect:save_temporary_scope_value_as] = {
    name = value_set[temporary_scope]
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope Can also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })
alias[effect:set_global_variable] = {
    name = value_set[global_variable]

    ## cardinality = 0..1
    enum[duration] = int

    ## cardinality = 0..1
    enum[duration] = { int int }

    ## cardinality = 0..1
    value = value_field
    ## cardinality = 0..1
    value = single_alias_right[formula]
    ## cardinality = 0..1
    value = <script_value>
    ## cardinality = 0..1
    value = <static_value>
    ## cardinality = 0..1
    value = $define_reference
    ## cardinality = 0..1
    value = scope_field
}

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_global_variable] = value_set[global_variable]

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_local_variable] = {
    name = value_set[local_variable]

    ## cardinality = 0..1
    enum[duration] = int

    ## cardinality = 0..1
    enum[duration] = { int int }

    ## cardinality = 0..1
    value = value_field
    ## cardinality = 0..1
    value = single_alias_right[formula]
    ## cardinality = 0..1
    value = <script_value>
    ## cardinality = 0..1
    value = <static_value>
    ## cardinality = 0..1
    value = $define_reference
    ## cardinality = 0..1
    value = scope_field
}

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_local_variable] = value_set[local_variable]

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_variable] = {
    name = value_set[variable]

    ## cardinality = 0..1
    enum[duration] = int

    ## cardinality = 0..1
    enum[duration] = { int int }
    ## cardinality = 0..1
    enum[duration] = <script_value>
    ## cardinality = 0..1
    enum[duration] = <static_value>

    ## cardinality = 0..1
    value = value_field
    ## cardinality = 0..1
    value = <script_value>
    ## cardinality = 0..1
    value = <static_value>
    ## cardinality = 0..1
    value = $define_reference
    ## cardinality = 0..1
    value = single_alias_right[formula]
    ## cardinality = 0..1
    value = scope_field
    ## cardinality = 0..1
    value = bool
}

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_variable] = value_set[variable]

### Effect only shown in tooltips (but not executed)
alias[effect:show_as_tooltip] = single_alias_right[effect_clause]

### Starts the tutorial lesson with the given key. Does nothing if the tutorial is not running, the lesson is completed (or already running), or the lesson cannot be triggered (e.g. trigger fails)
alias[effect:start_tutorial_lesson] = {
    tutorial_lesson = <tutorial_lesson>
    ## cardinality = 0..1
    journal_entry = scope[journal_entry]
}

### Switch on a trigger for the evaluation of another trigger with an optional fallback trigger.
alias[effect:switch] = {
    trigger = alias_keys_field[trigger]
    ## cardinality = 0..inf
    scalar = { alias_name[effect] = alias_match_left[effect] }
    ## cardinality = 0..1
    fallback = { alias_name[effect] = alias_match_left[effect] }
}

### Triggers an event for the current scope trigger_event = X trigger_event = { id = X days/weeks/months/years = Y } Where X is an event ID and Y is an integer to delay the event by
alias[effect:trigger_event] = <event>

### Triggers an event for the current scope trigger_event = X trigger_event = { id = X days/weeks/months/years = Y } Where X is an event ID and Y is an integer to delay the event by
alias[effect:trigger_event] = {
    id = <event>
    ## cardinality = 0..1
    enum[duration] = int

    ## cardinality = 0..1
    enum[duration] = { int int }
    ## cardinality = 0..1
    popup = bool
}

### Sets the state region for the scoped company, so the company building can be built there
## scopes = { company }
alias[effect:set_company_state_region] = scope[state_region]

### Repeats enclosed effects while limit criteria are met or until set iteration count is reached while = { limit = { <triggers> } <effects> }  while = { count = 3 <effects> } Default max of 1000.
alias[effect:while] = {
    ## cardinality = 0..1
    count = int
    ## cardinality = 0..1
    limit = {
        ## cardinality = 1..inf
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alias_name[effect] = alias_match_left[effect]
}

# TODO: Is this <building> or scope[building]?
### Activate a building in a state activate_building = { building = building_key }
alias[effect:activate_building] = {
    building = <building>
}

### Apply a standard of living modifier in the scoped state for the given culture. Other than the required culture argument, this effect has the same syntax as add_modifier.
alias[effect:add_culture_standard_of_living_modifier] = {
    culture = scope[culture]
    ## cardinality = 0..1
    enum[duration] = int
    ## cardinality = 0..1
    enum[duration] = <script_value>
    ## cardinality = 0..1
    enum[duration] = <static_value>
    ## cardinality = 0..1
    enum[duration] = enum[duration]

    ## cardinality = 0..1
    enum[duration] = { int int }
    ## cardinality = 0..1
    multiplier = value_field
    ## cardinality = 0..1
    multiplier = single_alias_right[formula]
    ## cardinality = 0..1
    multiplier = <script_value>
    ## cardinality = 0..1
    multiplier = <static_value>
    ## cardinality = 0..1
    multiplier = $define_reference
}

### Apply a standard of living modifier in the scoped state for the given religion. Other than the required religion argument, this effect has the same syntax as add_modifier.
alias[effect:add_religion_standard_of_living_modifier] = {
    religion = scope[religion]
    ## cardinality = 0..1
    enum[duration] = int

    ## cardinality = 0..1
    enum[duration] = { int int }
    ## cardinality = 0..1
    multiplier = value_field
    multiplier = single_alias_right[formula]
    multiplier = <script_value>
    multiplier = <static_value>
    multiplier = $define_reference
}

### Changes X% of the different religion population to the specified religion. convert_population = { target = rel:catholic value = 0.5 }
## scopes = { state }
alias[effect:convert_population] = {
    target = scope[religion]
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Creates a building in the scoped state. Supported values are: 	building = <building> 	activate_production_methods = { <production_methods> } 	subsidized = yes/no 	reserves = [0..1] (percentage of cash reserves the building should be created with) 	level = arable_land/integer  If level is "arable_land", the building will be of the necessary level to exhaust all available arable land in the state. If level is "urbanization", the building will be of the necessary level to exhaust all available urbanzation in the state. If level is an integer, the building will be of that level  Please note: this effect works a little differently if there already is a building of the specified type in the state. If that happens: 	1. the level will be the maximum between the scripted level and the level of the existing building 	2. the cash reserves will be the maximum between the scripted value and the existing cash reserves
alias[effect:create_building] = {
    building = <building>
    ## cardinality = 0..1
    activate_production_methods = {
        ## cardinality = 0..inf
        <production_method>
    }
    ## cardinality = 0..1
    subsidized = bool
    ## cardinality = 0..1
    reserves = value_field[0..1]
    ## cardinality = 0..1
    level = value_field
    ## cardinality = 0..1
    level = arable_land
    ## cardinality = 0..1
    level = urbanization

    ## cardinality = 0..1
    add_ownership = {
        ## cardinality = 0..inf
        building = {
            type = <building>
            country = scope[country]
            levels = int
            region = <state_region>
        }
        ## cardinality = 0..inf
        country = {
            country = scope[country]
            levels = int
        }
        ## cardinality = 0..inf
        company = {
            type = <company_type>
            country = scope[country]
            levels = int
        }
    }
}

### Creates a pop in the scoped state
alias[effect:create_pop] = {
    culture = <culture>
    size = int_value_field
    ## cardinality = 0..1
    pop_type = <pop_type>
    ## cardinality = 0..1
    religion = <religion>
}

### Deactivate a building in a state deactivate_building = { building = building_key }
alias[effect:deactivate_building] = {
    building = <building>
}

### Forces a resource depletion in state force_resource_depletion = bg_gold_mining
alias[effect:force_resource_depletion] = <building_group>

### Forces a resource discovery in state force_resource_discovery = bg_gold_mining
alias[effect:force_resource_discovery] = <building_group>

### Remove a building in the scope state remove_building = building_key
alias[effect:remove_building] = <building>

### Set State Owner set_state_owner = scope
alias[effect:set_state_owner] = scope[country]

### Sets a state to a certain type (incorporated, unincorporated, treaty_port)
alias[effect:set_state_type] = enum[state_type]

### Start constructing a building in a scoped state start_building_construction = building_barracks
alias[effect:start_building_construction] = <building>

### Add/remove arable land from a state region
alias[effect:add_arable_land] = int_value_field

### Adds scoped state region as a claim for target country add_claim = scope/country
alias[effect:add_claim] = scope[country]

### Add/remove devastation from a state region
alias[effect:add_devastation] = int_value_field

### Adds scoped state region as Homeland for target culture add_homeland = scope/culture
alias[effect:add_homeland] = <culture>
alias[effect:add_homeland] = scope[culture]

### Increase/decrease pollution level in a scoped state region add_pollution = 10
alias[effect:add_pollution] = int_value_field

### creates a state in a state region
alias[effect:create_state] = {
    country = scope[country]
    owned_provinces = {
        ## cardinality = ~1..inf
        enum[provinces]
    }
    ## cardinality = 0..inf
    state_type = enum[state_type]
}

### Removes scoped state region as a claim for target country add_claim = scope/country
alias[effect:remove_claim] = scope[country]

### Removes scoped state region as Homeland for target culture add_homeland = scope/culture
alias[effect:remove_homeland] = scope[culture]
### Removes scoped state region as Homeland for target culture add_homeland = scope/culture
alias[effect:remove_homeland] = <culture>

### Set devastation to a state region
alias[effect:set_devastation] = int_value_field

### Gives a set of provinces in a state region to a specific country set_owner_of_provinces = { country = <scope> provinces = {} }
alias[effect:set_owner_of_provinces] = {
    country = scope[country]
    provinces = {
        ## cardinality = ~1..inf
        enum[provinces]
    }
}

### Sets a (new) target technology scope for a journal entry set_target_technology = <scope>
alias[effect:set_target_technology] = scope[technology]

### Activates a law for a country
alias[effect:activate_law] = scope[law_type]

### Adds a total ban of a good to a country add_banned_goods = <goods key/scope>
alias[effect:add_banned_goods] = scope[goods]

### Add progress towards changing relations between two countries add_change_relations_progress = { 	tcountry = country scope/tag 	value = amount }
alias[effect:add_change_relations_progress] = {
    country = scope[country]
    country = <country_definition>
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Will create a declared interest in the target strategic region c:FRA = { add_declared_interest = region_nile_basin }
alias[effect:add_declared_interest] = <strategic_region>

### Adds an enactment-related timed modifier effect to object in scope
alias[effect:add_enactment_modifier] = {
    name = <modifier_container>
    ## cardinality = 0..1
    multiplier = value_field
}

### Add specified era as researched in a country scope add_era_researched = era
alias[effect:add_era_researched] = <era>

### Directly adds money to the investment pool add_investment_pool = 50
alias[effect:add_investment_pool] = int_value_field

### Adds x% progress to the current checkpoint of the law being passed (range is [0, 1], 0.1 means 10 percentage points) add_law_progress = 0.1 / -0.1
alias[effect:add_law_progress] = value_field[-1..1]

### Adds a culture to the primary cultures of a country add_primary_culture = X Where X is a culture scope
alias[effect:add_primary_culture] = scope[culture]

### Adds consumption taxes on a good to a country add_taxed_goods = <goods key/scope>
alias[effect:add_taxed_goods] = scope[goods]

### Add technology progress add_technology_progress = { progress = X technology = Y } Where X is a fixed point and Y is an technology
alias[effect:add_technology_progress] = {
    technology = <technology>
    progress = value_field
}

### Research the specified technology in a country scope add_technology_researched = technology
alias[effect:add_technology_researched] = <technology>

### Add/remove money from a country add_treasury = fixed point
alias[effect:add_treasury] = value_field
### Add/remove money from a country add_treasury = fixed point
alias[effect:add_treasury] = single_alias_right[formula]

### Annexes a country annex = scope
alias[effect:annex] = scope[country]

### Sets the next election date for country in N months call_election = { 	months = 6 }
alias[effect:call_election] = single_alias_right[duration_clause]

### Add/remove the investment level for the institution change_institution_investment_level = {  	institution = institution_police 	investment = -1 }
alias[effect:change_institution_investment_level] = {
    institution = <institution>
    investment = int_value_field
}

### Change relations between two countries change_relations = { 	tcountry = country scope/tag 	value = amount }
alias[effect:change_relations] = {
    country = scope[country]
    country = <country_definition>
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Will change the subject type of the country that is the current scope. change_subject_type = subject_type_dominion
alias[effect:change_subject_type] = <subject_type>

### Change the tag for the scoped country c:GBR = { change_tag = FRA }
alias[effect:change_tag] = <country_definition>

### Change tension between two countries change_tension = { 	tcountry = country scope/tag 	value = amount }
alias[effect:change_tension] = {
    country = scope[country]
    country = <country_definition>
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Clear country loans = bool
alias[effect:clear_debt] = bool

### Clears an amount of debt equal to the defined multiplier on target's max credit clear_scaled_debt = value
alias[effect:clear_scaled_debt] = value_field

### Completes an objective subgoal complete_objective_subgoal = <key>
alias[effect:complete_objective_subgoal] = <objective_subgoal>

### Creates a character, any option can be omitted. create_character = { 	name = loc_key or alternatively first_name and last_name separately 	culture = culture_tag 	religion = religion scope (if omitted, it's defined by the character's culture religion) 	female = bool or character scope (gets the same value from the character) 	noble = bool or character scope (gets the same value from the character) 	ruler = bool or character scope (gets the same value from the character) 	heir = bool 	age = integer, range, or character scope (gets the age from a character) 	ideology = ideology key or scope 	interest_group = interest group key or scope 	on_created = effect	trait_generation = effect	role = character scope (gets the role from a character) 	hq = HQ scope or strategic region scope }
alias[effect:create_character] = {
    ## cardinality = 0..1
    name = localisation
    ## cardinality = 0..1
    first_name = localisation
    ## cardinality = 0..1
    last_name = localisation

    ## cardinality = 0..1
    is_agitator = bool

    ## cardinality = 0..1
    culture = <culture>
    ## cardinality = 0..1
    culture = scope[culture]

    ## cardinality = 0..1
    religion = <religion>
    ## cardinality = 0..1
    religion = scope[religion]

    ## cardinality = 0..1
    female = bool
    ## cardinality = 0..1
    female = scope[character]

    ## cardinality = 0..1
    heir = bool

    ## cardinality = 0..1
    age = int_value_field
    ## cardinality = 0..1
    age = scope[character]

    ## cardinality = 0..1
    birth_date = date_field

    ## cardinality = 0..1
    ideology = <ideology>
    ## cardinality = 0..1
    ideology = scope[ideology]

    ## cardinality = 0..1
    interest_group = <interest_group>
    ## cardinality = 0..1
    interest_group = scope[interest_group]

    ## cardinality = 0..1
    ig_leader = bool

    ## cardinality = 0..1
    is_general = bool

    ## cardinality = 0..1
    is_admiral = bool

    ## cardinality = 0..1
    commander_rank = <commander_rank>
    ## cardinality = 0..1
    commander_rank = default

    ## cardinality = 0..1
    ruler = bool
    ## cardinality = 0..1
    ruler = scope[character]

    ## cardinality = 0..1
    noble = bool
    ## cardinality = 0..1
    noble = scope[character]

    ## cardinality = 0..1
    on_created = single_alias_right[effect_clause]

    ## cardinality = 0..1
    trait_generation = single_alias_right[effect_clause]

    ## cardinality = 0..1
    traits = {
        ## cardinality = 0..inf
        <character_trait>
    }

    ## cardinality = 0..1
    historical = bool

    ## cardinality = 0..1
    role = scope[character]

    #TODO add hq scope?
    ## cardinality = 0..1
    hq = scope[strategic_region]
    ## cardinality = 0..1
    hq = <strategic_region>

    ## cardinality = 0..1
    dna = <dna_data>

    ## cardinality = 0..1
    template = <character_template>
    ## cardinality = 0..1
    save_scope_as = value_set[event_target]
}

### Create a diplomatic pact between two countries, with scope country as initiator create_diplomatic_pact = { 	country = country scope/tag 	type = diplomatic action type }
alias[effect:create_diplomatic_pact] = {
    country = scope[country]
    country = <country_definition>
    type = <diplomatic_action>
}

### Set liberty desire of a subject country
alias[effect:add_liberty_desire] = int_value_field

### Set liberty desire of a subject country
alias[effect:add_liberty_desire] = single_alias_right[formula]

### Set liberty desire of a subject country
alias[effect:add_liberty_desire] = <script_value>

### Set liberty desire of a subject country
alias[effect:add_liberty_desire] = <static_value>

### Create a diplomatic play with the scoped object as target create_diplomatic_play = { 	name = loc_key 	escalation = integer between 0 and 100 	war = bool 	initiator = country scope/tag 	type = diplomatic play type 	add_initiator_backers = { list of country scopes/tags } 	add_target_backers = { list of country scopes/tags } 	add_war_goal = { holder = country scope/tag, type = x, state = <state target>, country = <country target,> region = <region target>  } }
alias[effect:create_diplomatic_play] = {
    ## cardinality = 0..1
    name = localisation

    ## cardinality = 0..1
    escalation = int_value_field[0..100]

    ## cardinality = 0..1
    war = bool

    ## cardinality = 0..1
    initiator = scope[country]
    ## cardinality = 0..1
    initiator = <country_definition>

    type = <diplomatic_play>

    ## cardinality = 0..1
    annex_as_civil_war = bool

    ## cardinality = 0..1
    target_state = scope[state]

    ## cardinality = 0..1
    target_country = scope[country]

    ## cardinality = 0..1
    target_region = scope[state_region]

    ## cardinality = 0..1
    add_initiator_backers = {
        ## cardinality = 0..inf
        scope[country]
        ## cardinality = 0..inf
        <country_definition>
    }

    ## cardinality = 0..1
    add_target_backers = {
        ## cardinality = 0..inf
        scope[country]
        ## cardinality = 0..inf
        <country_definition>
    }

    ## cardinality = 0..inf
    add_war_goal = {
        holder = scope[country]
        holder = <country_definition>
        type = enum[war_goal]

        ## cardinality = 0..1
        target_state = scope[state]
        ## cardinality = 0..1
        target_country = scope[country]
        ## cardinality = 0..1
        target_region = scope[state_region]
        ## cardinality = 0..1
        primary_demand = bool
    }
}

### Creates a diplomatic incident that generates infamy, with target country as the victim create_incident = { 	tcountry = country scope/tag 	value = infamy amount }
alias[effect:create_incident] = {
    country = scope[country]
    country = <country_definition>
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Creates a new Trade Route trade_route = { 	goods = x 	level = x 	import = yes/no 	origin = state_region 	target = state_region }
alias[effect:create_trade_route] = {
    goods = <good>
    level = int_value_field
    ## cardinality = 0..1
    import = bool
    ## cardinality = 0..1
    origin = scope[market]
    #TODO: market?
    target = scope[market]
    direction = import
    direction = export
}

### Create a truce betweeen two countries create_truce = { 	tcountry = country scope/tag 	months = integer }
alias[effect:create_truce] = {
    country = scope[country]
    country = <country_definition>
    months = int_value_field
}

### Deactivates a law for a country
alias[effect:deactivate_law] = scope[law_type]

### Deactivates parties in scoped country. deactivate_parties = yes
alias[effect:deactivate_parties] = yes

### Ends a truce betweeen two countries end_truce = { 	tcountry = country scope/tag 	months = integer }
alias[effect:end_truce] = scope[country]

### Makes a country independent. make_independent = bool
alias[effect:make_independent] = bool

### Change which country scoped country's player will play as play_as = <scope>
alias[effect:play_as] = scope[country]

### Recalculates and updates a country's pop IG memberships = bool
alias[effect:recalculate_pop_ig_support] = bool

### Removes an active objective subgoal remove_active_objective_subgoal = <key>
alias[effect:remove_active_objective_subgoal] = <objective_subgoal>

### Removes a total ban of a good from a country remove_banned_goods = <goods key/scope>
alias[effect:remove_banned_goods] = scope[goods]

### Removes a diplomatic pact between two countries, with scope country as initiator remove_diplomatic_pact = { 	country = country scope/tag 	type = diplomatic action type }
alias[effect:remove_diplomatic_pact] = {
    country = scope[country]
    country = <country_definition>
    type = <diplomatic_action>
}

### Removes an enactment-related timed modifier effect to object in scope
alias[effect:remove_enactment_modifier] = replace_me

### Removes an enactment-related timed modifier effect to object in scope
alias[effect:kill_population_percent_in_state] = {
    percent = value_field[0..1]

    ## cardinality = 0..1
    pop_type = <pop_type>

    ## cardinality = 0..1
    religion = scope[religion]

    ## cardinality = 0..1
    culture = scope[culture]

    ## cardinality = 0..1
    strata = enum[pop_strata]
}

### Removes a culture from the primary cultures of a country remove_primary_culture = X Where X is a culture scope
alias[effect:remove_primary_culture] = scope[culture]

### Removes consumption taxes on a good from a country remove_taxed_goods = <goods key/scope>
alias[effect:remove_taxed_goods] = scope[goods]

### Set capital state in a country scope set_capital = X Where X is a state region
alias[effect:set_capital] = <state_region>

### Sets the type of country for a country, for history
alias[effect:set_country_type] = <country_type>

### Set diplomats expelled = bool or scope county
alias[effect:set_diplomats_expelled] = bool

### Set diplomats expelled = bool or scope county
alias[effect:set_diplomats_expelled] = scope[country]

### Sets the government wage level of scoped country set_government_wage_level = very_low/low/medium/high/very_high
alias[effect:set_government_wage_level] = enum[wage_level]

### Sets the investment level for an institution set_institution_investment_level = { institution = <key> level = x }
alias[effect:set_institution_investment_level] = {
    institution = <institution>
    level = int_value_field
}

### Set market capital in a country scope set_market_capital = X Where X is a state region
alias[effect:set_market_capital] = <state_region>

### Sets the military wage level of scoped country set_military_wage_level = very_low/low/medium/high/very_high
alias[effect:set_military_wage_level] = enum[wage_level]

### Set mutual secret AI goal for scope country and target country set_mutual_secret_goal = { 	tcountry = country scope/tag 	secret_goal = secret goal type }
alias[effect:set_mutual_secret_goal] = {
    country = scope[country]
    country = <country_definition>
    secret_goal = enum[secret_goal]
}

### Set next election date for country set_next_election_date = year.month.day
alias[effect:set_next_election_date] = date_field

### Set whether a country owes another a obligation set_owes_obligation = { 	country = country scope/tag 	setting = yes/no }
alias[effect:set_owes_obligation_to] = {
    country = scope[country]
    country = <country_definition>
    setting = bool
}

### Set relations between two countries set_relations = { 	tcountry = country scope/tag 	value = amount }
alias[effect:set_relations] = {
    country = scope[country]
    country = <country_definition>
    value = int_value_field
}

### Creates a government for the country in scope from a set of interest groups set_ruling_interest_groups = { ig_tag1 ig_tag2 }
alias[effect:set_ruling_interest_groups] = {
    ## cardinality = 1..inf
    <interest_group>
}

### Set a secret AI goal for scope country towards another country set_secret_goal = { 	tcountry = country scope/tag 	secret_goal = secret goal type }
alias[effect:set_secret_goal] = {
    country = scope[country]
    country = <country_definition>
    secret_goal = enum[secret_goal]
}

### Changes the state religion of the country to the specified religion set_state_religion = X Where X is a religion scope
alias[effect:set_state_religion] = scope[religion]

### Set AI strategy for scope country set_strategy = <key>
alias[effect:set_strategy] = <ai_strategy>

### Sets Export Prioritized tariffs for a good in scoped country set_tariffs_export_priority = <scope/key>
alias[effect:set_tariffs_export_priority] = scope[goods]

### Sets Import Prioritized tariffs for a good in scoped country set_tariffs_import_priority = <scope/key>
alias[effect:set_tariffs_import_priority] = scope[goods]

### Sets tariffs to have no import/export priority for a good in scoped country set_tariffs_no_priority = <scope/key>
alias[effect:set_tariffs_no_priority] = scope[goods]

### Sets the overall tax level of scoped country set_tax_level = very_low/low/medium/high/very_high
alias[effect:set_tax_level] = enum[wage_level]

### Set tension between two countries set_tension = { 	tcountry = country scope/tag 	value = amount }
alias[effect:set_tension] = {
    country = scope[country]
    country = <country_definition>
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Scoped country starts research of any random technology they can start_research_random_technology = yes
alias[effect:start_research_random_technology] = yes

### Transfers an amount of debt equal to the defined multiplier on target's max credit take_on_scaled_debt = { 	who = <country> 	value = decimal value }
alias[effect:take_on_scaled_debt] = {
    who = scope[country]
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Updates party support in scoped country. update_party_support = yes
alias[effect:update_party_support] = yes

### Validates subsidies across a country's buildings. validate_subsidies = bool
alias[effect:validate_subsidies] = bool

### Target joins scoped war violate_sovereignty_accept = <country>
alias[effect:violate_sovereignty_join] = {
    violator = scope[country]
    target = scope[country]
    join_violator = bool
}

### Activates the named production method for buildings of a certain type in country/state
alias[effect:activate_production_method] = {
    building_type = <building>
    production_method = <production_method>
}

### Adds loyalists to pops in state or country, all parameters except value are optional add_loyalists = { value = x pop_type = <key> strata = <key> culture = <scope/cu:key> religion = <scope/rel:key> }
alias[effect:add_loyalists] = {
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
    ## cardinality = 0..1
    pop_type = <pop_type>
    ## cardinality = 0..1
    strata = enum[pop_strata]
    ## cardinality = 0..1
    culture = scope[culture]
    ## cardinality = 0..1
    religion = scope[religion]
    ## cardinality = 0..1
    interest_group = scope[interest_group]
}

### Adds radicals to pops in state or country, all parameters except value are optional add_radicals = { value = x pop_type = <key> strata = <key> culture = <scope/cu:key> religion = <scope/rel:key> }
alias[effect:add_radicals] = {
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
    ## cardinality = 0..1
    pop_type = <pop_type>
    ## cardinality = 0..1
    strata = enum[pop_strata]
    ## cardinality = 0..1
    culture = scope[culture]
    ## cardinality = 0..1
    religion = scope[religion]
    ## cardinality = 0..1
    interest_group = scope[interest_group]
}

### Adds the wealth of the pop add_pop_wealth = { wealth_distribution = {...} update_loyalties = true/false } Where the distribution adding to wealth of the pop
alias[effect:add_pop_wealth] = value_field
### Adds the wealth of the pop add_pop_wealth = { wealth_distribution = {...} update_loyalties = true/false } Where the distribution adding to wealth of the pop
alias[effect:add_pop_wealth] = <script_value>
### Adds the wealth of the pop add_pop_wealth = { wealth_distribution = {...} update_loyalties = true/false } Where the distribution adding to wealth of the pop
alias[effect:add_pop_wealth] = <static_value>

### Changes the culture of the scoped pop to a specified culture by a specified percentage change_pop_culture = { target = cu:spanish value = 0.33 }
alias[effect:change_pop_culture] = {
    target = scope[culture]
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Changes the religion of the scoped pop to a specified religion by a specified percentage change_pop_religion = { target = rel:catholic value = 0.5 }
alias[effect:change_pop_religion] = {
    target = scope[religion]
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Adds an acceptance delta for a culture in a state
## scopes = { state }
alias[effect:add_acceptance] = {
    culture = scope[culture]
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Changes the type of the pop to the given type
alias[effect:change_poptype] = scope[pop_type]

### Moves the scoped pop to the specified state (they become unemployed) move_pop = s:STATE_TUSCANY.region_state:TUS  NOTE: VERY IMPORTANT! This effect _may_ change the pop type of the moved pop. This will happen under the following conditions: 1. if the current pop type cannot be unemployed, the new pop type will be the default one 2.if the current pop type is a slave type and the target state does not allow slavery, the new pop type will be the default one
alias[effect:move_pop] = scope[state]

### Sets the literacy of the pop set_pop_literacy = { literacy_rate = {...} } Where the ratio is a script value computing the percentage of (workforce) pops that will be literate
alias[effect:set_pop_literacy] = {
    literacy_rate = value_field
    literacy_rate = single_alias_right[formula]
}

### Sets the pop qualifications of the pop for the given type set_pop_qualifications = { pop_type = {} qualifications = {...} } Where the qualifications is a script value computing the percentage of (workforce) pops that will have the qualifications
alias[effect:set_pop_qualifications] = replace_me

### Sets the wealth of the pop set_pop_wealth = { wealth_distribution = {...} update_loyalties = true/false } Where wealth is a script values
alias[effect:set_pop_wealth] = {
    wealth_distribution = value_field
    wealth_distribution = single_alias_right[formula]
    ## cardinality = 0..1
    update_loyalties = bool
}

### Adds war support to the target country in the scoped diplomatic play. The amount will appear under the 'situations' header in tooltips add_diplomatic_play_war_support = { target = country value = value }
alias[effect:add_diplomatic_play_war_support] = replace_me

### Add escalation to a diplomatic play add_escalation = integer
alias[effect:add_escalation] = int_value_field

### Add a tag/scope country to the initiator side of a diplomatic play add_initiator_backers = { list of scopes/tags }
alias[effect:add_initiator_backers] = {
    ## cardinality = 1..inf
    scope[country]
}

### Add a tag/scope country to the target side of a diplomatic play add_target_backers = { list of scopes/tags }
alias[effect:add_target_backers] = {
    ## cardinality = 1..inf
    scope[country]
}

### Adds a war goal to a DP. Same data read in as add_war_goal in create_diplomatic_play random_diplomatic_play = { add_war_goal = { holder = initiator type = secession }
alias[effect:add_war_goal] = {
    holder = scope[country]
    holder = <country_definition>
    type = enum[war_goal]

    ## cardinality = 0..1
    target_state = scope[state]
    ## cardinality = 0..1
    target_country = scope[country]
    ## cardinality = 0..1
    target_region = scope[state_region]
    ## cardinality = 0..1
    primary_demand = bool
}

### End a diplomatic play end_play = bool
alias[effect:end_play] = bool

### Remove a tag/scope country from the initiator side of a diplomatic play remove_initiator_backers = { list of scopes/tags }
alias[effect:remove_initiator_backers] = {
    ## cardinality = 1..inf
    scope[country]
}

### Remove a tag/scope country to the target side of a diplomatic play remove_target_backers = { list of scopes/tags }
alias[effect:remove_target_backers] = {
    ## cardinality = 1..inf
    scope[country]
}

### Removes a war goal from a DP if there's at least one other war goal present. any_diplomatic_play = { limit = { has_war_goal = return_state } remove_war_goal = { who = initiator war_goal = return_state } }
alias[effect:remove_war_goal] = {
    who = scope[country]
    war_goal = enum[war_goal]
}

### effect end diplo play for one side, with it gaining war goals resolve_play_for = initiator resolve_play_for = scope:custom_scoped_country
alias[effect:resolve_play_for] = scope[country]

### Set name to a diplomatic play set_key = loc_key
alias[effect:set_key] = localisation

### Set a diplomatic play to be a war set_war = bool
alias[effect:set_war] = bool

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:round_global_variable] = {
    name = value[global_variable]
    nearest = value_field
}

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:round_local_variable] = {
    name = value[local_variable]
    nearest = value_field
}

### Saves the current scope as an arbitrarily-named temporary target to be referenced later in the same effect save_temporary_event_target_as = <string>
alias[effect:save_temporary_scope_as] = value_set[temporary_scope]

### Adds company type to a country's companies
alias[effect:add_company] = scope[company_type]

### Adds the specified amount of Morale to the Combat Unit in scope
alias[effect:add_morale] = value_field

### Adds the specified amount of Morale to the Combat Unit in scope
alias[effect:add_morale] = single_alias_right[formula]

### Adds the specified amount of Organization to the Military Formation in scope
alias[effect:add_organization] = value_field

### Adds the specified amount of Organization to the Military Formation in scope
alias[effect:add_organization] = single_alias_right[formula]

### add state trait in a scoped state region
alias[effect:add_state_trait] = <state_trait>

### Annexes a country, inheriting incorporation of their states
alias[effect:annex_with_incorporation] = scope[country]

### Changes the culture of the scoped character change_character_culture = cu:colombian
alias[effect:change_character_culture] = scope[culture]

### Copies the constitution of the target country scope Warning: This stops any current enactment.
alias[effect:copy_laws] = scope[country]

### Creates a new country with a dynamic tag. Parameters: origin, country_type, tier, culture, religion, capital, cede_state_trigger, color, primary_unit_color, secondary_unit_color, tertiary_unit_color, on_created
alias[effect:create_dynamic_country] = {
    ## cardinality = 0..1
    ### optional, newly created country may inherit certain values from the origin country
    origin = scope[country]

    ## cardinality = 0..1
    ### optional if origin is set, may be repeated, will try to inherit country type from origin if not specified
    country_type = <country_type>

    ## cardinality = 0..1
    ### optional if origin is set, may be repeated, will try to inherit country tier from origin if not specified
    tier = enum[country_tier]

    ## cardinality = 0..1
    ### optional if origin is set, may be repeated, will try to inherit cultures from origin if not specified
    culture = scope[culture]

    ## cardinality = 0..1
    ### optional if origin is set, if no religion is specified, will try to inherit religion from origin if not specified
    religion = scope[religion]

    ## cardinality = 0..1
    ### optional if states have been supplied, will try to set a capital from supplied states if not specified
    capital = scope[state]

    ## cardinality = 0..1
    ## push_scope = state
    ### if this trigger is set, each state in the world for which it evaluates true will be ceded to the new country
    cede_state_trigger = single_alias_right[trigger_clause]

    ## cardinality = 0..1
    ### optional, will try to inherit map color from origin if not specified
    color = scalar

    ## cardinality = 0..1
    ### optional, will try to inherit unit color from origin if not specified
    primary_unit_color = scalar

    ## cardinality = 0..1
    ### optional, will try to inherit unit color from origin if not specified
    secondary_unit_color = scalar

    ## cardinality = 0..1
    ### optional, will try to inherit unit color from origin if not specified
    tertiary_unit_color = scalar

    ## cardinality = 0..1
    ## push_scope = country
    ### optional effect that will be run with the newly created country in scope
    on_created = single_alias_right[effect_clause]
}

###  Initiates mass migration of a specific culture from a origin country to a scoped state
alias[effect:create_mass_migration] = {
    origin = scope[country]
    culture = scope[culture]
}

### Creates a military formation
alias[effect:create_military_formation] = {
    ## cardinality = 0..1
    name = localisation

    ## cardinality = 0..1
    ### type defaults to army
    type = enum[military_formation_type]

    hq_region = scope[strategic_region]

    ## cardinality = 1..inf
    ### Add as many combat unit specifications as necessary
    combat_unit = {
        type = scope[combat_unit_type]

        ## cardinality = 0..1
        ### service type defaults to regular and conscript is not applicable for fleets
        service_type = enum[service_type]

        state_region = scope[state_region]

        count = int
    }

    ## cardinality = 0..1
    ### Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain save_event_target_as = <string>
    save_scope_as = value_set[event_target]

    ## cardinality = 0..1
    ### mobilization_options are not applicable for fleets
    mobilization_options = {
        ## cardinality = 0..inf
        scope[mobilization_option]
    }
}

### Deploys the scope formation to the target front
alias[effect:deploy_to_front] = scope[front]

###  Fully mobilizes scope army
alias[effect:fully_mobilize_army] = bool

### Mobilizes scope army
alias[effect:mobilize_army] = bool

### Removes company type from a country's companies
alias[effect:remove_company] = scope[company_type]

### remove state trait in a scoped state region
alias[effect:remove_state_trait] = <state_trait>

### Mark a character as busy and immortal or clear said mark
alias[effect:set_character_busy_and_immortal] = bool

### Set scoped character as immortal.
alias[effect:set_character_immortal] = bool

### Makes a country immune to revolutions or removes such immunity.
alias[effect:set_immune_to_revolutions] = bool

### Teleports the scope formation to the target front
alias[effect:teleport_to_front] = scope[front]

### Transfers scope character to target formation
alias[effect:transfer_to_formation] = scope[military_formation]

### Starts enacting the specified law type for the country in scope  
alias[effect:start_enactment] = scope[law_type]

### Sets the establishment date of scope company
## scopes = { company }
alias[effect:set_company_establishment_date] = date_field

### Allows only one party
alias[effect:set_only_legal_party_from_ig] = scope[interest_group]

### Allows more than one party
alias[effect:unset_only_legal_party] = bool

### Seize investment pool of private sector
alias[effect:seize_investment_pool] = bool

alias[effect:create_diplomatic_catalyst] = {
    type = <diplomatic_catalyst>
    target = scope[country]
}

alias[effect:create_bidirectional_truce] = {
    country = scope[country]
    enum[duration] = int_value_field

    ## cardinality = 0..1
    enum[duration] = { int int }
}

alias[effect:create_unidirectional_truce] = {
    country = scope[country]
    enum[duration] = int_value_field

    ## cardinality = 0..1
    enum[duration] = { int int }
}

### Change appeasement value of a lobby
alias[effect:change_appeasement] = {
    amount = int_value_field
    factor = <political_lobby_appeasement>
}

### Country joins power bloc in scope
alias[effect:join_power_bloc] = scope[country]

### Add leverage to another country
alias[effect:add_leverage] = {
    target = scope[country]
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Add progress to a scripted progress bar
alias[effect:add_progress] = {
    name = <scripted_progress_bar>
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}

### Add cohesion to a power bloc
alias[effect:add_cohesion_percent] = {
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
}
### Add cohesion to a power bloc
alias[effect:add_cohesion_percent] = value_field
### Add cohesion to a power bloc
alias[effect:add_cohesion_percent] = <script_value>
### Add cohesion to a power bloc
alias[effect:add_cohesion_percent] = <static_value>

### Change regime in a country
alias[effect:regime_change] = scope[country]

### Decrease autonomy of country
alias[effect:decrease_autonomy] = bool

### Decrease autonomy of country
alias[effect:increase_autonomy] = bool

### Makes target join a scoped war in a specific side.
## scopes = { war }
alias[effect:join_war] = {
    target = scope[country]
    side = scope[country]
}

### Set a character's home country. This makes them start considering themselves as having been exiled, i.e. was_exiled starts evaluating to yes for them.
## scopes = { character }
alias[effect:set_home_country] = scope[country]

### Make a character the ruler of the country he is in
alias[effect:set_character_as_ruler] = bool

### Remove a specific role from a character
alias[effect:remove_character_role] = enum[character_role]

### Rename a state
alias[effect:set_state_name] = localisation

### Rename a hub of a state
alias[effect:set_hub_name] = {
    type = enum[city_type]
    name = localisation
}

### Rename all hubs of a state
alias[effect:set_hub_names] = localisation

### Reset the name of a state
alias[effect:reset_state_name] = bool

### Reset the name of all hubs in a state
alias[effect:reset_hub_names] = bool

### Disinherit a character from transfer of power
alias[effect:disinherit_character] = bool

### Exiles a character from the current country
alias[effect:exile_character] = bool

### Rename a hub of a state
alias[effect:set_bar_progress] = {
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference
    name = <scripted_progress_bar>
}

## scopes = { country }
### Cancels the enactment of the current law
alias[effect:cancel_enactment] = bool

## scopes = { law }
### Cancels the imposition of the scope law on the country
alias[effect:cancel_imposition] = bool

## scopes = { state }
### Adds loyalists to a state
alias[effect:add_loyalists_in_state] = {
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference

    ## cardinality = 0..1
    religion = scope[religion]

    ## cardinality = 0..1
    culture = scope[culture]

    ## cardinality = 0..1
    pop_type = <pop_type>

    ## cardinality = 0..1
    strata = enum[pop_strata]
}

## scopes = { state }
### Adds radicals to a state
alias[effect:add_radicals_in_state] = {
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference

    ## cardinality = 0..1
    religion = scope[religion]

    ## cardinality = 0..1
    culture = scope[culture]

    ## cardinality = 0..1
    pop_type = <pop_type>

    ## cardinality = 0..1
    strata = enum[pop_strata]
}

## scopes = { country }
### Create a political movement in scope country
alias[effect:create_political_movement] = {
    type = <political_movement>

    ## cardinality = 0..1
    religion = scope[religion]

    ## cardinality = 0..1
    culture = scope[culture]

    ## cardinality = 0..1
    strata = enum[pop_strata]
}

## scopes = { country }
### Create a political movement in scope country
alias[effect:create_power_bloc] = {
    name = localisation

    map_color = enum[named_colors]
    map_color = colour[rgb]
    map_color = colour[hsv]
    map_color = colour[hsv360]
    ## color_type = hsv
    map_color = {
        ## cardinality = 3..3
        base = float
    }
    ## color_type = rgb
    map_color = {
        ## cardinality = 3..3
        base = int[0..255]
    }
    ## color_type = hex
    map_color = scalar

    founding_date = date_field

    identity = <power_bloc_identity>

    principle = <power_bloc_principle>

    ## cardinality = 0..inf
    member = scope[country]
}

## scopes = { political_movement }
### Set the core ideology for a political_movement
alias[effect:set_core_ideology] = <ideology>

## scopes = { country }
### Add to a specified enactment phase of the current law
alias[effect:add_enactment_phase] = int[1..3]

## scopes = { party }
### Sets party as the ruling party
alias[effect:set_ruling_party] = bool

## scopes = { country }
### Creates a political lobby
alias[effect:create_political_lobby] = {
    type = <political_lobby>
    target = scope[country]

    ## cardinality = 0..inf
    religion = scope[religion]

    ## cardinality = 1..inf
    add_interest_group = scope[interest_group]
}

## scopes = { power_bloc }
### Adds a principle to a power bloc
alias[effect:add_principle] = <power_bloc_principle>

## scopes = { state }
### Forbid autonomous investment from country
alias[effect:unset_available_for_autonomous_investment] = scope[country]

## scopes = { state }
### Allow autonomous investment from country
alias[effect:set_available_for_autonomous_investment] = scope[country]

## scopes = { state_region }
### Starts a harvest condition in the given state region
alias[effect:start_harvest_condition] = <harvest_condition_type>

## scopes = { political_movement }
### Adds a character ideology to the scoped political movement
alias[effect:add_character_ideology] = scope[ideology]

## scopes = { political_movement }
### Removes a character ideology from the scoped political movement
alias[effect:remove_character_ideology] = scope[ideology]

## scopes = { power_bloc }
### Adds a specific amount of Cohesion to the Power Bloc in scope
### add_cohesion_number = 100 [adds 100 points to Cohesion]
alias[effect:add_cohesion_number] = value

## scopes = { state }
### Adds a cultural community for the target culture in the scoped state.
### scope:some_state = { add_cultural_community = cu:zulu }
alias[effect:add_cultural_community] = scope[culture]

## scopes = { culture }
### Adds a cultural community for the scoped culture in the target state.
### cu:zulu = { add_cultural_community_in_state = scope:some_state }
alias[effect:add_cultural_community_in_state] = scope[state]

## scopes = { country }
### Changes the current law enactment setback count in scope country by an added amount.
### The result will be clamped between 0 and country_law_max_setbacks_add The law enactment will fail if the resulting value equals country_law_max_setbacks_add
alias[effect:add_enactment_setback] = int

## scopes = { party }
### Adds target interest group to scope party
### py:py_key = { add_ig_to_party = ig:ig_key }
alias[effect:add_ig_to_party] = scope[interest_group]

## scopes = { political_lobby }
### Adds an interest group as a member of scope political lobby
### add_lobby_member = scope:interest_group
alias[effect:add_lobby_member] = scope[interest_group]

## scopes = { country }
### Annexes a country with all the inheritance effects of a victorious side in a civil war
### annex_as_civil_war = scope
alias[effect:annex_as_civil_war] = scope[country]

## scopes = { country }
### Clears the current law enactment modifier of scope country.
alias[effect:clear_enactment_modifier] = bool

## scopes = { party }
### Removes all interest groups from the party, causing it to disband
alias[effect:disband_party] = bool

## scopes = { political_lobby }
### Disband scoped political lobby
### disband_political_lobby = yes
alias[effect:disband_political_lobby] = bool

## scopes = { state_region }
### Finish a harvest condition of type in the scoped state region
### finish_harvest_condition = <key>
alias[effect:finish_harvest_condition] = <harvest_condition_type>

## scopes = { state_region }
### Finish a harvest condition of type in the scoped state region
### finish_harvest_condition = <key>
alias[effect:finish_harvest_condition] = scope[harvest_condition_type]

## scopes = { state }
### Kills a number of individuals in the population in the scoped state.
###
### All parameters except percent are optional. Pop type and strata cannot be used at the same time.kill_population = {
###    value = <integer value>
###    culture = <scope/cu:key>
###    religion = <scope/rel:key>
###    interest_group = <scope/ig:key>
###    pop_type = <scope/pop_type:key>
###    strata = <key>
### }
alias[effect:kill_population_in_state] = {
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference

    ## cardinality = 0..1
    pop_type = <pop_type>

    ## cardinality = 0..1
    religion = scope[religion]

    ## cardinality = 0..1
    culture = scope[culture]

    ## cardinality = 0..1
    strata = enum[pop_strata]
}

## scopes = { country }
### Kills a percentage of the population in the scoped country.
###
### All parameters except percent are optional. Pop type and strata cannot be used at the same time.kill_population_percent = {
###    percent = <decimal value>
###    culture = <scope/cu:key>
###    religion = <scope/rel:key>
###    interest_group = <scope/ig:key>
###    pop_type = <scope/pop_type:key>
###    strata = <key>
### }
alias[effect:kill_population_percent] = {
    value = value_field
    value = single_alias_right[formula]
    value = <script_value>
    value = <static_value>
    value = $define_reference

    ## cardinality = 0..1
    pop_type = <pop_type>

    ## cardinality = 0..1
    religion = scope[religion]

    ## cardinality = 0..1
    culture = scope[culture]

    ## cardinality = 0..1
    strata = enum[pop_strata]
}

## scopes = { pop }
### Moves the scoped pop to the specified state (they become unemployed)
### move_partial_pop = { state = s:STATE_TUSCANY.region_state:TUS }
### move_partial_pop = { state = s:STATE_TUSCANY.region_state:TUS population = 1000 }
###  move_partial_pop = { state = s:STATE_TUSCANY.region_state:TUS population_ratio = 0.2 }
###
### NOTE: VERY IMPORTANT! This effect _may_ change the pop type of the moved pop. This will happen under the following conditions:
### 1. if the current pop type cannot be unemployed, the new pop type will be the default one
### 2.if the current pop type is a slave type and the target state does not allow slavery, the new pop type will be the default one
alias[effect:move_partial_pop] = {
    state = scope[state]

    ## cardinality = 0..1
    population = value_field
    ## cardinality = 0..1
    population = single_alias_right[formula]
    ## cardinality = 0..1
    population = <script_value>
    ## cardinality = 0..1
    population = <static_value>
    ## cardinality = 0..1
    population = $define_reference

    ## cardinality = 0..1
    population_ratio = value_field
    ## cardinality = 0..1
    population_ratio = single_alias_right[formula]
    ## cardinality = 0..1
    population_ratio = <script_value>
    ## cardinality = 0..1
    population_ratio = <static_value>
    ## cardinality = 0..1
    population_ratio = $define_reference
}

## scopes = { political_movement }
### Removes a character ideology from the scoped political movement
### remove_character_ideology = x
alias[effect:remove_character_ideology] = <ideology>

## scopes = { party }
### Removes target interest group from scope party
### py:py_key = {
###    remove_ig_from_party = ig:ig_key
### }
alias[effect:remove_ig_from_party] = scope[interest_group]

## scopes = { party }
### Removes target interest group from scope party
### py:py_key = {
###    remove_ig_from_party = ig:ig_key
### }
alias[effect:remove_ig_from_party] = scope[interest_group]

## scopes = { political_lobby }
### Removes an interest group as a member of scope political lobby
### remove_lobby_member = scope:interest_group
alias[effect:remove_lobby_member] = scope[interest_group]

## scopes = { power_bloc }
### Removes principle from powerbloc
### power_bloc = {
###    remove_principle = test_principle_group_A_1
### }
alias[effect:remove_principle] = <power_bloc_principle>

## scopes = { political_movement }
### Starts/stops bolstering the political movement in scope
### set_bolstering = yes/no
alias[effect:set_bolstering] = bool

## scopes = { political_movement }
### Starts/stops suppressing the political movement in scope
### set_suppression = yes/no
alias[effect:set_suppression] = bool

## scopes = { country }
### Sets the heir of the scoped country to the character scope specified
### set_heir = scope:victoria
alias[effect:set_heir] = scope[character]

## scopes = { character }
### Set a character's home country directly to a tag, you can use this to avoid making sure that the tag exists, this makes them an exile
### set_home_country_definition = cd:FRA
alias[effect:set_home_country_definition] = scope[country_definition]

## scopes = { character }
### Sets the interest group of the character
### set_interest_group = ruler.interest_group
alias[effect:set_interest_group] = scope[interest_group]

## scopes = { country }
### Sets the social hierarchy the scoped country
### set_social_hierarchy = <key>
alias[effect:set_social_hierarchy] = <social_hierarchy>

## scopes = { any }
### Sorts a variable list
### sort_global_variable_list = { name = X order = Y }
### Where X is the name of the variable
### Where Y is some math script to determine sort order
alias[effect:sort_global_variable_list] = {
    name = value_set[global_variable_list]
    order = single_alias_right[formula]
    order = <script_value>
}

## scopes = { any }
### Sorts a variable list
### sort_local_variable_list = { name = X order = Y }
### Where X is the name of the variable
### Where Y is some math script to determine sort order
alias[effect:sort_local_variable_list] = {
    name = value_set[local_variable_list]
    order = single_alias_right[formula]
    order = <script_value>
}

## scopes = { any }
### Sorts a variable list
### sort_variable_list = { name = X order = Y }
### Where X is the name of the variable
### Where Y is some math script to determine sort order
alias[effect:sort_variable_list] = {
    name = value_set[variable_list]
    order = single_alias_right[formula]
    order = <script_value>
}

## scopes = { state }
### Start constructing a building in a scoped state as a private construction
### start_privately_funded_building_construction = building_barracks
alias[effect:start_privately_funded_building_construction] = <building>

## scopes = { country }
### Tries to form a new govt with provided IGs, If not possible with legitimacy provided will try and add as many IGs into the govt as possible
### try_form_government_with = {
###     value = 30
###     interest_group_type = ig_armed_forces
###     interest_group_type = ig_devout
###     interest_group_type = ig_landowners
### }
alias[effect:try_form_government_with] = {
    value = int[1..100]

    ## cardinality = 1..inf
    interest_group_type = <interest_group>
}